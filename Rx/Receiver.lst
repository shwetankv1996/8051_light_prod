                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 3.9.4 #11418 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module Receiver
                                      6 	.optsdcc -mmcs51 --model-small
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _main
                                     12 	.globl _isr_timer0
                                     13 	.globl _TF2
                                     14 	.globl _EXF2
                                     15 	.globl _RCLK
                                     16 	.globl _TCLK
                                     17 	.globl _EXEN2
                                     18 	.globl _TR2
                                     19 	.globl _C_T2
                                     20 	.globl _CP_RL2
                                     21 	.globl _T2CON_7
                                     22 	.globl _T2CON_6
                                     23 	.globl _T2CON_5
                                     24 	.globl _T2CON_4
                                     25 	.globl _T2CON_3
                                     26 	.globl _T2CON_2
                                     27 	.globl _T2CON_1
                                     28 	.globl _T2CON_0
                                     29 	.globl _PT2
                                     30 	.globl _ET2
                                     31 	.globl _CY
                                     32 	.globl _AC
                                     33 	.globl _F0
                                     34 	.globl _RS1
                                     35 	.globl _RS0
                                     36 	.globl _OV
                                     37 	.globl _F1
                                     38 	.globl _P
                                     39 	.globl _PS
                                     40 	.globl _PT1
                                     41 	.globl _PX1
                                     42 	.globl _PT0
                                     43 	.globl _PX0
                                     44 	.globl _RD
                                     45 	.globl _WR
                                     46 	.globl _T1
                                     47 	.globl _T0
                                     48 	.globl _INT1
                                     49 	.globl _INT0
                                     50 	.globl _TXD
                                     51 	.globl _RXD
                                     52 	.globl _P3_7
                                     53 	.globl _P3_6
                                     54 	.globl _P3_5
                                     55 	.globl _P3_4
                                     56 	.globl _P3_3
                                     57 	.globl _P3_2
                                     58 	.globl _P3_1
                                     59 	.globl _P3_0
                                     60 	.globl _EA
                                     61 	.globl _ES
                                     62 	.globl _ET1
                                     63 	.globl _EX1
                                     64 	.globl _ET0
                                     65 	.globl _EX0
                                     66 	.globl _P2_7
                                     67 	.globl _P2_6
                                     68 	.globl _P2_5
                                     69 	.globl _P2_4
                                     70 	.globl _P2_3
                                     71 	.globl _P2_2
                                     72 	.globl _P2_1
                                     73 	.globl _P2_0
                                     74 	.globl _SM0
                                     75 	.globl _SM1
                                     76 	.globl _SM2
                                     77 	.globl _REN
                                     78 	.globl _TB8
                                     79 	.globl _RB8
                                     80 	.globl _TI
                                     81 	.globl _RI
                                     82 	.globl _P1_7
                                     83 	.globl _P1_6
                                     84 	.globl _P1_5
                                     85 	.globl _P1_4
                                     86 	.globl _P1_3
                                     87 	.globl _P1_2
                                     88 	.globl _P1_1
                                     89 	.globl _P1_0
                                     90 	.globl _TF1
                                     91 	.globl _TR1
                                     92 	.globl _TF0
                                     93 	.globl _TR0
                                     94 	.globl _IE1
                                     95 	.globl _IT1
                                     96 	.globl _IE0
                                     97 	.globl _IT0
                                     98 	.globl _P0_7
                                     99 	.globl _P0_6
                                    100 	.globl _P0_5
                                    101 	.globl _P0_4
                                    102 	.globl _P0_3
                                    103 	.globl _P0_2
                                    104 	.globl _P0_1
                                    105 	.globl _P0_0
                                    106 	.globl _TH2
                                    107 	.globl _TL2
                                    108 	.globl _RCAP2H
                                    109 	.globl _RCAP2L
                                    110 	.globl _T2CON
                                    111 	.globl _B
                                    112 	.globl _ACC
                                    113 	.globl _PSW
                                    114 	.globl _IP
                                    115 	.globl _P3
                                    116 	.globl _IE
                                    117 	.globl _P2
                                    118 	.globl _SBUF
                                    119 	.globl _SCON
                                    120 	.globl _P1
                                    121 	.globl _TH1
                                    122 	.globl _TH0
                                    123 	.globl _TL1
                                    124 	.globl _TL0
                                    125 	.globl _TMOD
                                    126 	.globl _TCON
                                    127 	.globl _PCON
                                    128 	.globl _DPH
                                    129 	.globl _DPL
                                    130 	.globl _SP
                                    131 	.globl _P0
                                    132 	.globl _dim_flag
                                    133 	.globl _auto_flag
                                    134 	.globl _ac_state
                                    135 	.globl _off
                                    136 	.globl _state
                                    137 	.globl _dim1_val2
                                    138 	.globl _dim1_val
                                    139 	.globl _dim_val2
                                    140 	.globl _dim_val
                                    141 	.globl _time_delay
                                    142 	.globl _dimCount
                                    143 	.globl _timerCount
                                    144 	.globl _data_r
                                    145 	.globl _start
                                    146 	.globl _startup
                                    147 	.globl _delay
                                    148 	.globl _UART_Init
                                    149 	.globl _Transmit_data
                                    150 	.globl _handshake
                                    151 	.globl _check_data
                                    152 	.globl _InitTimer0
                                    153 	.globl _check_switches
                                    154 ;--------------------------------------------------------
                                    155 ; special function registers
                                    156 ;--------------------------------------------------------
                                    157 	.area RSEG    (ABS,DATA)
      000000                        158 	.org 0x0000
                           000080   159 _P0	=	0x0080
                           000081   160 _SP	=	0x0081
                           000082   161 _DPL	=	0x0082
                           000083   162 _DPH	=	0x0083
                           000087   163 _PCON	=	0x0087
                           000088   164 _TCON	=	0x0088
                           000089   165 _TMOD	=	0x0089
                           00008A   166 _TL0	=	0x008a
                           00008B   167 _TL1	=	0x008b
                           00008C   168 _TH0	=	0x008c
                           00008D   169 _TH1	=	0x008d
                           000090   170 _P1	=	0x0090
                           000098   171 _SCON	=	0x0098
                           000099   172 _SBUF	=	0x0099
                           0000A0   173 _P2	=	0x00a0
                           0000A8   174 _IE	=	0x00a8
                           0000B0   175 _P3	=	0x00b0
                           0000B8   176 _IP	=	0x00b8
                           0000D0   177 _PSW	=	0x00d0
                           0000E0   178 _ACC	=	0x00e0
                           0000F0   179 _B	=	0x00f0
                           0000C8   180 _T2CON	=	0x00c8
                           0000CA   181 _RCAP2L	=	0x00ca
                           0000CB   182 _RCAP2H	=	0x00cb
                           0000CC   183 _TL2	=	0x00cc
                           0000CD   184 _TH2	=	0x00cd
                                    185 ;--------------------------------------------------------
                                    186 ; special function bits
                                    187 ;--------------------------------------------------------
                                    188 	.area RSEG    (ABS,DATA)
      000000                        189 	.org 0x0000
                           000080   190 _P0_0	=	0x0080
                           000081   191 _P0_1	=	0x0081
                           000082   192 _P0_2	=	0x0082
                           000083   193 _P0_3	=	0x0083
                           000084   194 _P0_4	=	0x0084
                           000085   195 _P0_5	=	0x0085
                           000086   196 _P0_6	=	0x0086
                           000087   197 _P0_7	=	0x0087
                           000088   198 _IT0	=	0x0088
                           000089   199 _IE0	=	0x0089
                           00008A   200 _IT1	=	0x008a
                           00008B   201 _IE1	=	0x008b
                           00008C   202 _TR0	=	0x008c
                           00008D   203 _TF0	=	0x008d
                           00008E   204 _TR1	=	0x008e
                           00008F   205 _TF1	=	0x008f
                           000090   206 _P1_0	=	0x0090
                           000091   207 _P1_1	=	0x0091
                           000092   208 _P1_2	=	0x0092
                           000093   209 _P1_3	=	0x0093
                           000094   210 _P1_4	=	0x0094
                           000095   211 _P1_5	=	0x0095
                           000096   212 _P1_6	=	0x0096
                           000097   213 _P1_7	=	0x0097
                           000098   214 _RI	=	0x0098
                           000099   215 _TI	=	0x0099
                           00009A   216 _RB8	=	0x009a
                           00009B   217 _TB8	=	0x009b
                           00009C   218 _REN	=	0x009c
                           00009D   219 _SM2	=	0x009d
                           00009E   220 _SM1	=	0x009e
                           00009F   221 _SM0	=	0x009f
                           0000A0   222 _P2_0	=	0x00a0
                           0000A1   223 _P2_1	=	0x00a1
                           0000A2   224 _P2_2	=	0x00a2
                           0000A3   225 _P2_3	=	0x00a3
                           0000A4   226 _P2_4	=	0x00a4
                           0000A5   227 _P2_5	=	0x00a5
                           0000A6   228 _P2_6	=	0x00a6
                           0000A7   229 _P2_7	=	0x00a7
                           0000A8   230 _EX0	=	0x00a8
                           0000A9   231 _ET0	=	0x00a9
                           0000AA   232 _EX1	=	0x00aa
                           0000AB   233 _ET1	=	0x00ab
                           0000AC   234 _ES	=	0x00ac
                           0000AF   235 _EA	=	0x00af
                           0000B0   236 _P3_0	=	0x00b0
                           0000B1   237 _P3_1	=	0x00b1
                           0000B2   238 _P3_2	=	0x00b2
                           0000B3   239 _P3_3	=	0x00b3
                           0000B4   240 _P3_4	=	0x00b4
                           0000B5   241 _P3_5	=	0x00b5
                           0000B6   242 _P3_6	=	0x00b6
                           0000B7   243 _P3_7	=	0x00b7
                           0000B0   244 _RXD	=	0x00b0
                           0000B1   245 _TXD	=	0x00b1
                           0000B2   246 _INT0	=	0x00b2
                           0000B3   247 _INT1	=	0x00b3
                           0000B4   248 _T0	=	0x00b4
                           0000B5   249 _T1	=	0x00b5
                           0000B6   250 _WR	=	0x00b6
                           0000B7   251 _RD	=	0x00b7
                           0000B8   252 _PX0	=	0x00b8
                           0000B9   253 _PT0	=	0x00b9
                           0000BA   254 _PX1	=	0x00ba
                           0000BB   255 _PT1	=	0x00bb
                           0000BC   256 _PS	=	0x00bc
                           0000D0   257 _P	=	0x00d0
                           0000D1   258 _F1	=	0x00d1
                           0000D2   259 _OV	=	0x00d2
                           0000D3   260 _RS0	=	0x00d3
                           0000D4   261 _RS1	=	0x00d4
                           0000D5   262 _F0	=	0x00d5
                           0000D6   263 _AC	=	0x00d6
                           0000D7   264 _CY	=	0x00d7
                           0000AD   265 _ET2	=	0x00ad
                           0000BD   266 _PT2	=	0x00bd
                           0000C8   267 _T2CON_0	=	0x00c8
                           0000C9   268 _T2CON_1	=	0x00c9
                           0000CA   269 _T2CON_2	=	0x00ca
                           0000CB   270 _T2CON_3	=	0x00cb
                           0000CC   271 _T2CON_4	=	0x00cc
                           0000CD   272 _T2CON_5	=	0x00cd
                           0000CE   273 _T2CON_6	=	0x00ce
                           0000CF   274 _T2CON_7	=	0x00cf
                           0000C8   275 _CP_RL2	=	0x00c8
                           0000C9   276 _C_T2	=	0x00c9
                           0000CA   277 _TR2	=	0x00ca
                           0000CB   278 _EXEN2	=	0x00cb
                           0000CC   279 _TCLK	=	0x00cc
                           0000CD   280 _RCLK	=	0x00cd
                           0000CE   281 _EXF2	=	0x00ce
                           0000CF   282 _TF2	=	0x00cf
                                    283 ;--------------------------------------------------------
                                    284 ; overlayable register banks
                                    285 ;--------------------------------------------------------
                                    286 	.area REG_BANK_0	(REL,OVR,DATA)
      000000                        287 	.ds 8
                                    288 ;--------------------------------------------------------
                                    289 ; overlayable bit register bank
                                    290 ;--------------------------------------------------------
                                    291 	.area BIT_BANK	(REL,OVR,DATA)
      000000                        292 bits:
      000000                        293 	.ds 1
                           008000   294 	b0 = bits[0]
                           008100   295 	b1 = bits[1]
                           008200   296 	b2 = bits[2]
                           008300   297 	b3 = bits[3]
                           008400   298 	b4 = bits[4]
                           008500   299 	b5 = bits[5]
                           008600   300 	b6 = bits[6]
                           008700   301 	b7 = bits[7]
                                    302 ;--------------------------------------------------------
                                    303 ; internal ram data
                                    304 ;--------------------------------------------------------
                                    305 	.area DSEG    (DATA)
      000000                        306 _start::
      000000                        307 	.ds 1
      000001                        308 _data_r::
      000001                        309 	.ds 1
      000002                        310 _timerCount::
      000002                        311 	.ds 2
      000004                        312 _dimCount::
      000004                        313 	.ds 2
      000006                        314 _time_delay::
      000006                        315 	.ds 2
      000008                        316 _dim_val::
      000008                        317 	.ds 2
      00000A                        318 _dim_val2::
      00000A                        319 	.ds 2
      00000C                        320 _dim1_val::
      00000C                        321 	.ds 2
      00000E                        322 _dim1_val2::
      00000E                        323 	.ds 2
      000010                        324 _state::
      000010                        325 	.ds 2
      000012                        326 _off::
      000012                        327 	.ds 2
      000014                        328 _ac_state::
      000014                        329 	.ds 1
                                    330 ;--------------------------------------------------------
                                    331 ; overlayable items in internal ram 
                                    332 ;--------------------------------------------------------
                                    333 	.area	OSEG    (OVR,DATA)
                                    334 	.area	OSEG    (OVR,DATA)
                                    335 ;--------------------------------------------------------
                                    336 ; Stack segment in internal ram 
                                    337 ;--------------------------------------------------------
                                    338 	.area	SSEG
      000000                        339 __start__stack:
      000000                        340 	.ds	1
                                    341 
                                    342 ;--------------------------------------------------------
                                    343 ; indirectly addressable internal ram data
                                    344 ;--------------------------------------------------------
                                    345 	.area ISEG    (DATA)
                                    346 ;--------------------------------------------------------
                                    347 ; absolute internal ram data
                                    348 ;--------------------------------------------------------
                                    349 	.area IABS    (ABS,DATA)
                                    350 	.area IABS    (ABS,DATA)
                                    351 ;--------------------------------------------------------
                                    352 ; bit data
                                    353 ;--------------------------------------------------------
                                    354 	.area BSEG    (BIT)
      000000                        355 _auto_flag::
      000000                        356 	.ds 1
      000001                        357 _dim_flag::
      000001                        358 	.ds 1
                                    359 ;--------------------------------------------------------
                                    360 ; paged external ram data
                                    361 ;--------------------------------------------------------
                                    362 	.area PSEG    (PAG,XDATA)
                                    363 ;--------------------------------------------------------
                                    364 ; external ram data
                                    365 ;--------------------------------------------------------
                                    366 	.area XSEG    (XDATA)
                                    367 ;--------------------------------------------------------
                                    368 ; absolute external ram data
                                    369 ;--------------------------------------------------------
                                    370 	.area XABS    (ABS,XDATA)
                                    371 ;--------------------------------------------------------
                                    372 ; external initialized ram data
                                    373 ;--------------------------------------------------------
                                    374 	.area XISEG   (XDATA)
                                    375 	.area HOME    (CODE)
                                    376 	.area GSINIT0 (CODE)
                                    377 	.area GSINIT1 (CODE)
                                    378 	.area GSINIT2 (CODE)
                                    379 	.area GSINIT3 (CODE)
                                    380 	.area GSINIT4 (CODE)
                                    381 	.area GSINIT5 (CODE)
                                    382 	.area GSINIT  (CODE)
                                    383 	.area GSFINAL (CODE)
                                    384 	.area CSEG    (CODE)
                                    385 ;--------------------------------------------------------
                                    386 ; interrupt vector 
                                    387 ;--------------------------------------------------------
                                    388 	.area HOME    (CODE)
      000000                        389 __interrupt_vect:
      000000 02r00r00         [24]  390 	ljmp	__sdcc_gsinit_startup
      000003 32               [24]  391 	reti
      000004                        392 	.ds	7
      00000B 02r00r00         [24]  393 	ljmp	_isr_timer0
                                    394 ;--------------------------------------------------------
                                    395 ; global & static initialisations
                                    396 ;--------------------------------------------------------
                                    397 	.area HOME    (CODE)
                                    398 	.area GSINIT  (CODE)
                                    399 	.area GSFINAL (CODE)
                                    400 	.area GSINIT  (CODE)
                                    401 	.globl __sdcc_gsinit_startup
                                    402 	.globl __sdcc_program_startup
                                    403 	.globl __start__stack
                                    404 	.globl __mcs51_genXINIT
                                    405 	.globl __mcs51_genXRAMCLEAR
                                    406 	.globl __mcs51_genRAMCLEAR
                                    407 ;	Receiver.c:34: char start=0;
      000000 75*00 00         [24]  408 	mov	_start,#0x00
                                    409 ;	Receiver.c:36: volatile int timerCount = 0;
      000003 E4               [12]  410 	clr	a
      000004 F5*02            [12]  411 	mov	_timerCount,a
      000006 F5*03            [12]  412 	mov	(_timerCount + 1),a
                                    413 ;	Receiver.c:37: volatile int dimCount = 0;
      000008 F5*04            [12]  414 	mov	_dimCount,a
      00000A F5*05            [12]  415 	mov	(_dimCount + 1),a
                                    416 ;	Receiver.c:38: volatile int time_delay = 15;
      00000C 75*06 0F         [24]  417 	mov	_time_delay,#0x0f
                                    418 ;	1-genFromRTrack replaced	mov	(_time_delay + 1),#0x00
      00000F F5*07            [12]  419 	mov	(_time_delay + 1),a
                                    420 ;	Receiver.c:39: volatile int dim_val = 8;
      000011 75*08 08         [24]  421 	mov	_dim_val,#0x08
                                    422 ;	1-genFromRTrack replaced	mov	(_dim_val + 1),#0x00
      000014 F5*09            [12]  423 	mov	(_dim_val + 1),a
                                    424 ;	Receiver.c:40: volatile int dim_val2 = 0;
      000016 F5*0A            [12]  425 	mov	_dim_val2,a
      000018 F5*0B            [12]  426 	mov	(_dim_val2 + 1),a
                                    427 ;	Receiver.c:41: volatile int dim1_val = 8;
      00001A 75*0C 08         [24]  428 	mov	_dim1_val,#0x08
                                    429 ;	1-genFromRTrack replaced	mov	(_dim1_val + 1),#0x00
      00001D F5*0D            [12]  430 	mov	(_dim1_val + 1),a
                                    431 ;	Receiver.c:42: volatile int dim1_val2 = 0;
      00001F F5*0E            [12]  432 	mov	_dim1_val2,a
      000021 F5*0F            [12]  433 	mov	(_dim1_val2 + 1),a
                                    434 	.area GSFINAL (CODE)
      000000 02r00r0E         [24]  435 	ljmp	__sdcc_program_startup
                                    436 ;--------------------------------------------------------
                                    437 ; Home
                                    438 ;--------------------------------------------------------
                                    439 	.area HOME    (CODE)
                                    440 	.area HOME    (CODE)
      00000E                        441 __sdcc_program_startup:
      00000E 02r05r0A         [24]  442 	ljmp	_main
                                    443 ;	return from main will return to caller
                                    444 ;--------------------------------------------------------
                                    445 ; code
                                    446 ;--------------------------------------------------------
                                    447 	.area CSEG    (CODE)
                                    448 ;------------------------------------------------------------
                                    449 ;Allocation info for local variables in function 'isr_timer0'
                                    450 ;------------------------------------------------------------
                                    451 ;	Receiver.c:46: void isr_timer0(void) __interrupt 1   // It is called after every 5msec
                                    452 ;	-----------------------------------------
                                    453 ;	 function isr_timer0
                                    454 ;	-----------------------------------------
      000000                        455 _isr_timer0:
                           000007   456 	ar7 = 0x07
                           000006   457 	ar6 = 0x06
                           000005   458 	ar5 = 0x05
                           000004   459 	ar4 = 0x04
                           000003   460 	ar3 = 0x03
                           000002   461 	ar2 = 0x02
                           000001   462 	ar1 = 0x01
                           000000   463 	ar0 = 0x00
      000000 C0*00            [24]  464 	push	bits
      000002 C0 E0            [24]  465 	push	acc
      000004 C0 F0            [24]  466 	push	b
      000006 C0 82            [24]  467 	push	dpl
      000008 C0 83            [24]  468 	push	dph
      00000A C0 07            [24]  469 	push	(0+7)
      00000C C0 06            [24]  470 	push	(0+6)
      00000E C0 05            [24]  471 	push	(0+5)
      000010 C0 04            [24]  472 	push	(0+4)
      000012 C0 03            [24]  473 	push	(0+3)
      000014 C0 02            [24]  474 	push	(0+2)
      000016 C0 01            [24]  475 	push	(0+1)
      000018 C0 00            [24]  476 	push	(0+0)
      00001A C0 D0            [24]  477 	push	psw
      00001C 75 D0 00         [24]  478 	mov	psw,#0x00
                                    479 ;	Receiver.c:48: TH0  = 0Xee;         // ReLoad the timer value for 5ms
      00001F 75 8C EE         [24]  480 	mov	_TH0,#0xee
                                    481 ;	Receiver.c:49: TL0  = 0X00;
      000022 75 8A 00         [24]  482 	mov	_TL0,#0x00
                                    483 ;	Receiver.c:50: timerCount++;
      000025 AE*02            [24]  484 	mov	r6,_timerCount
      000027 AF*03            [24]  485 	mov	r7,(_timerCount + 1)
      000029 74 01            [12]  486 	mov	a,#0x01
      00002B 2E               [12]  487 	add	a,r6
      00002C F5*02            [12]  488 	mov	_timerCount,a
      00002E E4               [12]  489 	clr	a
      00002F 3F               [12]  490 	addc	a,r7
      000030 F5*03            [12]  491 	mov	(_timerCount + 1),a
                                    492 ;	Receiver.c:51: dimCount++;
      000032 AE*04            [24]  493 	mov	r6,_dimCount
      000034 AF*05            [24]  494 	mov	r7,(_dimCount + 1)
      000036 74 01            [12]  495 	mov	a,#0x01
      000038 2E               [12]  496 	add	a,r6
      000039 F5*04            [12]  497 	mov	_dimCount,a
      00003B E4               [12]  498 	clr	a
      00003C 3F               [12]  499 	addc	a,r7
      00003D F5*05            [12]  500 	mov	(_dimCount + 1),a
                                    501 ;	Receiver.c:52: rst_out=!rst_out;
      00003F B2 96            [12]  502 	cpl	_P1_6
                                    503 ;	Receiver.c:54: if(state!=20)
      000041 74 14            [12]  504 	mov	a,#0x14
      000043 B5*10 07         [24]  505 	cjne	a,_state,00408$
      000046 E4               [12]  506 	clr	a
      000047 B5*11 03         [24]  507 	cjne	a,(_state + 1),00408$
      00004A 02r04rED         [24]  508 	ljmp	00230$
      00004D                        509 00408$:
                                    510 ;	Receiver.c:56: if(timerCount < (time_delay*30)) // count for LED-ON delay
      00004D 85*06*00         [24]  511 	mov	__mulint_PARM_2,_time_delay
      000050 85*07*01         [24]  512 	mov	(__mulint_PARM_2 + 1),(_time_delay + 1)
      000053 90 00 1E         [24]  513 	mov	dptr,#0x001e
      000056 12r00r00         [24]  514 	lcall	__mulint
      000059 AE 82            [24]  515 	mov	r6,dpl
      00005B AF 83            [24]  516 	mov	r7,dph
      00005D C3               [12]  517 	clr	c
      00005E E5*02            [12]  518 	mov	a,_timerCount
      000060 9E               [12]  519 	subb	a,r6
      000061 E5*03            [12]  520 	mov	a,(_timerCount + 1)
      000063 64 80            [12]  521 	xrl	a,#0x80
      000065 8F F0            [24]  522 	mov	b,r7
      000067 63 F0 80         [24]  523 	xrl	b,#0x80
      00006A 95 F0            [12]  524 	subb	a,b
      00006C 40 03            [24]  525 	jc	00409$
      00006E 02r03rC2         [24]  526 	ljmp	00226$
      000071                        527 00409$:
                                    528 ;	Receiver.c:58: switch(state)
      000071 E5*11            [12]  529 	mov	a,(_state + 1)
      000073 30 E7 03         [24]  530 	jnb	acc.7,00410$
      000076 02r04rED         [24]  531 	ljmp	00230$
      000079                        532 00410$:
      000079 C3               [12]  533 	clr	c
      00007A 74 09            [12]  534 	mov	a,#0x09
      00007C 95*10            [12]  535 	subb	a,_state
      00007E 74 80            [12]  536 	mov	a,#(0x00 ^ 0x80)
      000080 85*11 F0         [24]  537 	mov	b,(_state + 1)
      000083 63 F0 80         [24]  538 	xrl	b,#0x80
      000086 95 F0            [12]  539 	subb	a,b
      000088 50 03            [24]  540 	jnc	00411$
      00008A 02r04rED         [24]  541 	ljmp	00230$
      00008D                        542 00411$:
      00008D E5*10            [12]  543 	mov	a,_state
      00008F 24 0B            [12]  544 	add	a,#(00412$-3-.)
      000091 83               [24]  545 	movc	a,@a+pc
      000092 F5 82            [12]  546 	mov	dpl,a
      000094 E5*10            [12]  547 	mov	a,_state
      000096 24 0E            [12]  548 	add	a,#(00413$-3-.)
      000098 83               [24]  549 	movc	a,@a+pc
      000099 F5 83            [12]  550 	mov	dph,a
      00009B E4               [12]  551 	clr	a
      00009C 73               [24]  552 	jmp	@a+dptr
      00009D                        553 00412$:
      00009DrB1                     554 	.db	00101$
      00009Er01                     555 	.db	00110$
      00009Fr50                     556 	.db	00119$
      0000A0r9F                     557 	.db	00128$
      0000A1rEE                     558 	.db	00137$
      0000A2r3D                     559 	.db	00146$
      0000A3r8C                     560 	.db	00155$
      0000A4rDB                     561 	.db	00164$
      0000A5r24                     562 	.db	00171$
      0000A6r73                     563 	.db	00180$
      0000A7                        564 00413$:
      0000A7s00                     565 	.db	00101$>>8
      0000A8s01                     566 	.db	00110$>>8
      0000A9s01                     567 	.db	00119$>>8
      0000AAs01                     568 	.db	00128$>>8
      0000ABs01                     569 	.db	00137$>>8
      0000ACs02                     570 	.db	00146$>>8
      0000ADs02                     571 	.db	00155$>>8
      0000AEs02                     572 	.db	00164$>>8
      0000AFs03                     573 	.db	00171$>>8
      0000B0s03                     574 	.db	00180$>>8
                                    575 ;	Receiver.c:60: case 0:	if(dim1_val)
      0000B1                        576 00101$:
      0000B1 E5*0C            [12]  577 	mov	a,_dim1_val
      0000B3 45*0D            [12]  578 	orl	a,(_dim1_val + 1)
      0000B5 60 16            [24]  579 	jz	00106$
                                    580 ;	Receiver.c:61: {dim1_val--;P0_1 =1;P0_0 =0;P2_6=1;}
      0000B7 AE*0C            [24]  581 	mov	r6,_dim1_val
      0000B9 AF*0D            [24]  582 	mov	r7,(_dim1_val + 1)
      0000BB EE               [12]  583 	mov	a,r6
      0000BC 24 FF            [12]  584 	add	a,#0xff
      0000BE F5*0C            [12]  585 	mov	_dim1_val,a
      0000C0 EF               [12]  586 	mov	a,r7
      0000C1 34 FF            [12]  587 	addc	a,#0xff
      0000C3 F5*0D            [12]  588 	mov	(_dim1_val + 1),a
                                    589 ;	assignBit
      0000C5 D2 81            [12]  590 	setb	_P0_1
                                    591 ;	assignBit
      0000C7 C2 80            [12]  592 	clr	_P0_0
                                    593 ;	assignBit
      0000C9 D2 A6            [12]  594 	setb	_P2_6
      0000CB 80 28            [24]  595 	sjmp	00107$
      0000CD                        596 00106$:
                                    597 ;	Receiver.c:63: else if(dim1_val2){dim1_val2--;P0_1 =0;P0_0 =0;P2_6=0;}
      0000CD E5*0E            [12]  598 	mov	a,_dim1_val2
      0000CF 45*0F            [12]  599 	orl	a,(_dim1_val2 + 1)
      0000D1 60 16            [24]  600 	jz	00103$
      0000D3 AE*0E            [24]  601 	mov	r6,_dim1_val2
      0000D5 AF*0F            [24]  602 	mov	r7,(_dim1_val2 + 1)
      0000D7 EE               [12]  603 	mov	a,r6
      0000D8 24 FF            [12]  604 	add	a,#0xff
      0000DA F5*0E            [12]  605 	mov	_dim1_val2,a
      0000DC EF               [12]  606 	mov	a,r7
      0000DD 34 FF            [12]  607 	addc	a,#0xff
      0000DF F5*0F            [12]  608 	mov	(_dim1_val2 + 1),a
                                    609 ;	assignBit
      0000E1 C2 81            [12]  610 	clr	_P0_1
                                    611 ;	assignBit
      0000E3 C2 80            [12]  612 	clr	_P0_0
                                    613 ;	assignBit
      0000E5 C2 A6            [12]  614 	clr	_P2_6
      0000E7 80 0C            [24]  615 	sjmp	00107$
      0000E9                        616 00103$:
                                    617 ;	Receiver.c:65: else {dim1_val = dim_val;dim1_val2 = dim_val2;}
      0000E9 85*08*0C         [24]  618 	mov	_dim1_val,_dim_val
      0000EC 85*09*0D         [24]  619 	mov	(_dim1_val + 1),(_dim_val + 1)
      0000EF 85*0A*0E         [24]  620 	mov	_dim1_val2,_dim_val2
      0000F2 85*0B*0F         [24]  621 	mov	(_dim1_val2 + 1),(_dim_val2 + 1)
      0000F5                        622 00107$:
                                    623 ;	Receiver.c:67: if(auto_flag)auto_led=1;
      0000F5 30*00 02         [24]  624 	jnb	_auto_flag,00109$
                                    625 ;	assignBit
      0000F8 D2 A1            [12]  626 	setb	_P2_1
      0000FA                        627 00109$:
                                    628 ;	Receiver.c:68: up_led=0;	down_led=0;
                                    629 ;	assignBit
      0000FA C2 A7            [12]  630 	clr	_P2_7
                                    631 ;	assignBit
      0000FC C2 A4            [12]  632 	clr	_P2_4
                                    633 ;	Receiver.c:69: break;	
      0000FE 02r04rED         [24]  634 	ljmp	00230$
                                    635 ;	Receiver.c:70: case 1:	if(dim1_val)
      000101                        636 00110$:
      000101 E5*0C            [12]  637 	mov	a,_dim1_val
      000103 45*0D            [12]  638 	orl	a,(_dim1_val + 1)
      000105 60 16            [24]  639 	jz	00115$
                                    640 ;	Receiver.c:71: {dim1_val--;P0_1 =1;P0_0 =0;P2_6=0;}
      000107 AE*0C            [24]  641 	mov	r6,_dim1_val
      000109 AF*0D            [24]  642 	mov	r7,(_dim1_val + 1)
      00010B EE               [12]  643 	mov	a,r6
      00010C 24 FF            [12]  644 	add	a,#0xff
      00010E F5*0C            [12]  645 	mov	_dim1_val,a
      000110 EF               [12]  646 	mov	a,r7
      000111 34 FF            [12]  647 	addc	a,#0xff
      000113 F5*0D            [12]  648 	mov	(_dim1_val + 1),a
                                    649 ;	assignBit
      000115 D2 81            [12]  650 	setb	_P0_1
                                    651 ;	assignBit
      000117 C2 80            [12]  652 	clr	_P0_0
                                    653 ;	assignBit
      000119 C2 A6            [12]  654 	clr	_P2_6
      00011B 80 28            [24]  655 	sjmp	00116$
      00011D                        656 00115$:
                                    657 ;	Receiver.c:73: else if(dim1_val2){dim1_val2--;P0_1 =0;P0_0 =0;P2_6=0;}
      00011D E5*0E            [12]  658 	mov	a,_dim1_val2
      00011F 45*0F            [12]  659 	orl	a,(_dim1_val2 + 1)
      000121 60 16            [24]  660 	jz	00112$
      000123 AE*0E            [24]  661 	mov	r6,_dim1_val2
      000125 AF*0F            [24]  662 	mov	r7,(_dim1_val2 + 1)
      000127 EE               [12]  663 	mov	a,r6
      000128 24 FF            [12]  664 	add	a,#0xff
      00012A F5*0E            [12]  665 	mov	_dim1_val2,a
      00012C EF               [12]  666 	mov	a,r7
      00012D 34 FF            [12]  667 	addc	a,#0xff
      00012F F5*0F            [12]  668 	mov	(_dim1_val2 + 1),a
                                    669 ;	assignBit
      000131 C2 81            [12]  670 	clr	_P0_1
                                    671 ;	assignBit
      000133 C2 80            [12]  672 	clr	_P0_0
                                    673 ;	assignBit
      000135 C2 A6            [12]  674 	clr	_P2_6
      000137 80 0C            [24]  675 	sjmp	00116$
      000139                        676 00112$:
                                    677 ;	Receiver.c:75: else {dim1_val = dim_val;dim1_val2 = dim_val2;}
      000139 85*08*0C         [24]  678 	mov	_dim1_val,_dim_val
      00013C 85*09*0D         [24]  679 	mov	(_dim1_val + 1),(_dim_val + 1)
      00013F 85*0A*0E         [24]  680 	mov	_dim1_val2,_dim_val2
      000142 85*0B*0F         [24]  681 	mov	(_dim1_val2 + 1),(_dim_val2 + 1)
      000145                        682 00116$:
                                    683 ;	Receiver.c:77: if(auto_flag)
      000145 20*00 03         [24]  684 	jb	_auto_flag,00419$
      000148 02r04rED         [24]  685 	ljmp	00230$
      00014B                        686 00419$:
                                    687 ;	Receiver.c:78: up_led=1;
                                    688 ;	assignBit
      00014B D2 A7            [12]  689 	setb	_P2_7
                                    690 ;	Receiver.c:79: break;
      00014D 02r04rED         [24]  691 	ljmp	00230$
                                    692 ;	Receiver.c:80: case 2:		if(dim1_val)
      000150                        693 00119$:
      000150 E5*0C            [12]  694 	mov	a,_dim1_val
      000152 45*0D            [12]  695 	orl	a,(_dim1_val + 1)
      000154 60 16            [24]  696 	jz	00124$
                                    697 ;	Receiver.c:81: {dim1_val--;P0_1 =1;P0_0 =0;P2_6=0;}
      000156 AE*0C            [24]  698 	mov	r6,_dim1_val
      000158 AF*0D            [24]  699 	mov	r7,(_dim1_val + 1)
      00015A EE               [12]  700 	mov	a,r6
      00015B 24 FF            [12]  701 	add	a,#0xff
      00015D F5*0C            [12]  702 	mov	_dim1_val,a
      00015F EF               [12]  703 	mov	a,r7
      000160 34 FF            [12]  704 	addc	a,#0xff
      000162 F5*0D            [12]  705 	mov	(_dim1_val + 1),a
                                    706 ;	assignBit
      000164 D2 81            [12]  707 	setb	_P0_1
                                    708 ;	assignBit
      000166 C2 80            [12]  709 	clr	_P0_0
                                    710 ;	assignBit
      000168 C2 A6            [12]  711 	clr	_P2_6
      00016A 80 28            [24]  712 	sjmp	00125$
      00016C                        713 00124$:
                                    714 ;	Receiver.c:83: else if(dim1_val2){dim1_val2--;P0_1 =0;P0_0 =0;P2_6=0;}
      00016C E5*0E            [12]  715 	mov	a,_dim1_val2
      00016E 45*0F            [12]  716 	orl	a,(_dim1_val2 + 1)
      000170 60 16            [24]  717 	jz	00121$
      000172 AE*0E            [24]  718 	mov	r6,_dim1_val2
      000174 AF*0F            [24]  719 	mov	r7,(_dim1_val2 + 1)
      000176 EE               [12]  720 	mov	a,r6
      000177 24 FF            [12]  721 	add	a,#0xff
      000179 F5*0E            [12]  722 	mov	_dim1_val2,a
      00017B EF               [12]  723 	mov	a,r7
      00017C 34 FF            [12]  724 	addc	a,#0xff
      00017E F5*0F            [12]  725 	mov	(_dim1_val2 + 1),a
                                    726 ;	assignBit
      000180 C2 81            [12]  727 	clr	_P0_1
                                    728 ;	assignBit
      000182 C2 80            [12]  729 	clr	_P0_0
                                    730 ;	assignBit
      000184 C2 A6            [12]  731 	clr	_P2_6
      000186 80 0C            [24]  732 	sjmp	00125$
      000188                        733 00121$:
                                    734 ;	Receiver.c:85: else {dim1_val = dim_val;dim1_val2 = dim_val2;}
      000188 85*08*0C         [24]  735 	mov	_dim1_val,_dim_val
      00018B 85*09*0D         [24]  736 	mov	(_dim1_val + 1),(_dim_val + 1)
      00018E 85*0A*0E         [24]  737 	mov	_dim1_val2,_dim_val2
      000191 85*0B*0F         [24]  738 	mov	(_dim1_val2 + 1),(_dim_val2 + 1)
      000194                        739 00125$:
                                    740 ;	Receiver.c:87: if(auto_flag)
      000194 20*00 03         [24]  741 	jb	_auto_flag,00422$
      000197 02r04rED         [24]  742 	ljmp	00230$
      00019A                        743 00422$:
                                    744 ;	Receiver.c:88: up_led=1;
                                    745 ;	assignBit
      00019A D2 A7            [12]  746 	setb	_P2_7
                                    747 ;	Receiver.c:89: break;
      00019C 02r04rED         [24]  748 	ljmp	00230$
                                    749 ;	Receiver.c:90: case 3:		if(dim1_val)
      00019F                        750 00128$:
      00019F E5*0C            [12]  751 	mov	a,_dim1_val
      0001A1 45*0D            [12]  752 	orl	a,(_dim1_val + 1)
      0001A3 60 16            [24]  753 	jz	00133$
                                    754 ;	Receiver.c:91: {dim1_val--;P0_1 =1;P0_0 =1;P2_6=0;}
      0001A5 AE*0C            [24]  755 	mov	r6,_dim1_val
      0001A7 AF*0D            [24]  756 	mov	r7,(_dim1_val + 1)
      0001A9 EE               [12]  757 	mov	a,r6
      0001AA 24 FF            [12]  758 	add	a,#0xff
      0001AC F5*0C            [12]  759 	mov	_dim1_val,a
      0001AE EF               [12]  760 	mov	a,r7
      0001AF 34 FF            [12]  761 	addc	a,#0xff
      0001B1 F5*0D            [12]  762 	mov	(_dim1_val + 1),a
                                    763 ;	assignBit
      0001B3 D2 81            [12]  764 	setb	_P0_1
                                    765 ;	assignBit
      0001B5 D2 80            [12]  766 	setb	_P0_0
                                    767 ;	assignBit
      0001B7 C2 A6            [12]  768 	clr	_P2_6
      0001B9 80 28            [24]  769 	sjmp	00134$
      0001BB                        770 00133$:
                                    771 ;	Receiver.c:93: else if(dim1_val2){dim1_val2--;P0_1 =0;P0_0 =0;P2_6=0;}
      0001BB E5*0E            [12]  772 	mov	a,_dim1_val2
      0001BD 45*0F            [12]  773 	orl	a,(_dim1_val2 + 1)
      0001BF 60 16            [24]  774 	jz	00130$
      0001C1 AE*0E            [24]  775 	mov	r6,_dim1_val2
      0001C3 AF*0F            [24]  776 	mov	r7,(_dim1_val2 + 1)
      0001C5 EE               [12]  777 	mov	a,r6
      0001C6 24 FF            [12]  778 	add	a,#0xff
      0001C8 F5*0E            [12]  779 	mov	_dim1_val2,a
      0001CA EF               [12]  780 	mov	a,r7
      0001CB 34 FF            [12]  781 	addc	a,#0xff
      0001CD F5*0F            [12]  782 	mov	(_dim1_val2 + 1),a
                                    783 ;	assignBit
      0001CF C2 81            [12]  784 	clr	_P0_1
                                    785 ;	assignBit
      0001D1 C2 80            [12]  786 	clr	_P0_0
                                    787 ;	assignBit
      0001D3 C2 A6            [12]  788 	clr	_P2_6
      0001D5 80 0C            [24]  789 	sjmp	00134$
      0001D7                        790 00130$:
                                    791 ;	Receiver.c:95: else {dim1_val = dim_val;dim1_val2 = dim_val2;}
      0001D7 85*08*0C         [24]  792 	mov	_dim1_val,_dim_val
      0001DA 85*09*0D         [24]  793 	mov	(_dim1_val + 1),(_dim_val + 1)
      0001DD 85*0A*0E         [24]  794 	mov	_dim1_val2,_dim_val2
      0001E0 85*0B*0F         [24]  795 	mov	(_dim1_val2 + 1),(_dim_val2 + 1)
      0001E3                        796 00134$:
                                    797 ;	Receiver.c:97: if(auto_flag)
      0001E3 20*00 03         [24]  798 	jb	_auto_flag,00425$
      0001E6 02r04rED         [24]  799 	ljmp	00230$
      0001E9                        800 00425$:
                                    801 ;	Receiver.c:98: up_led=1;
                                    802 ;	assignBit
      0001E9 D2 A7            [12]  803 	setb	_P2_7
                                    804 ;	Receiver.c:99: break;
      0001EB 02r04rED         [24]  805 	ljmp	00230$
                                    806 ;	Receiver.c:100: case 4:		if(dim1_val)
      0001EE                        807 00137$:
      0001EE E5*0C            [12]  808 	mov	a,_dim1_val
      0001F0 45*0D            [12]  809 	orl	a,(_dim1_val + 1)
      0001F2 60 16            [24]  810 	jz	00142$
                                    811 ;	Receiver.c:101: {dim1_val--;P0_1 =0;P0_0 =1;P2_6=1;}
      0001F4 AE*0C            [24]  812 	mov	r6,_dim1_val
      0001F6 AF*0D            [24]  813 	mov	r7,(_dim1_val + 1)
      0001F8 EE               [12]  814 	mov	a,r6
      0001F9 24 FF            [12]  815 	add	a,#0xff
      0001FB F5*0C            [12]  816 	mov	_dim1_val,a
      0001FD EF               [12]  817 	mov	a,r7
      0001FE 34 FF            [12]  818 	addc	a,#0xff
      000200 F5*0D            [12]  819 	mov	(_dim1_val + 1),a
                                    820 ;	assignBit
      000202 C2 81            [12]  821 	clr	_P0_1
                                    822 ;	assignBit
      000204 D2 80            [12]  823 	setb	_P0_0
                                    824 ;	assignBit
      000206 D2 A6            [12]  825 	setb	_P2_6
      000208 80 28            [24]  826 	sjmp	00143$
      00020A                        827 00142$:
                                    828 ;	Receiver.c:103: else if(dim1_val2){dim1_val2--;P0_1 =0;P0_0 =0;P2_6=0;}
      00020A E5*0E            [12]  829 	mov	a,_dim1_val2
      00020C 45*0F            [12]  830 	orl	a,(_dim1_val2 + 1)
      00020E 60 16            [24]  831 	jz	00139$
      000210 AE*0E            [24]  832 	mov	r6,_dim1_val2
      000212 AF*0F            [24]  833 	mov	r7,(_dim1_val2 + 1)
      000214 EE               [12]  834 	mov	a,r6
      000215 24 FF            [12]  835 	add	a,#0xff
      000217 F5*0E            [12]  836 	mov	_dim1_val2,a
      000219 EF               [12]  837 	mov	a,r7
      00021A 34 FF            [12]  838 	addc	a,#0xff
      00021C F5*0F            [12]  839 	mov	(_dim1_val2 + 1),a
                                    840 ;	assignBit
      00021E C2 81            [12]  841 	clr	_P0_1
                                    842 ;	assignBit
      000220 C2 80            [12]  843 	clr	_P0_0
                                    844 ;	assignBit
      000222 C2 A6            [12]  845 	clr	_P2_6
      000224 80 0C            [24]  846 	sjmp	00143$
      000226                        847 00139$:
                                    848 ;	Receiver.c:105: else {dim1_val = dim_val;dim1_val2 = dim_val2;}
      000226 85*08*0C         [24]  849 	mov	_dim1_val,_dim_val
      000229 85*09*0D         [24]  850 	mov	(_dim1_val + 1),(_dim_val + 1)
      00022C 85*0A*0E         [24]  851 	mov	_dim1_val2,_dim_val2
      00022F 85*0B*0F         [24]  852 	mov	(_dim1_val2 + 1),(_dim_val2 + 1)
      000232                        853 00143$:
                                    854 ;	Receiver.c:107: if(auto_flag)
      000232 20*00 03         [24]  855 	jb	_auto_flag,00428$
      000235 02r04rED         [24]  856 	ljmp	00230$
      000238                        857 00428$:
                                    858 ;	Receiver.c:108: down_led=1;
                                    859 ;	assignBit
      000238 D2 A4            [12]  860 	setb	_P2_4
                                    861 ;	Receiver.c:109: break;
      00023A 02r04rED         [24]  862 	ljmp	00230$
                                    863 ;	Receiver.c:110: case 5:		if(dim1_val)
      00023D                        864 00146$:
      00023D E5*0C            [12]  865 	mov	a,_dim1_val
      00023F 45*0D            [12]  866 	orl	a,(_dim1_val + 1)
      000241 60 16            [24]  867 	jz	00151$
                                    868 ;	Receiver.c:111: {dim1_val--;P0_1 =0;P0_0 =0;P2_6=1;}
      000243 AE*0C            [24]  869 	mov	r6,_dim1_val
      000245 AF*0D            [24]  870 	mov	r7,(_dim1_val + 1)
      000247 EE               [12]  871 	mov	a,r6
      000248 24 FF            [12]  872 	add	a,#0xff
      00024A F5*0C            [12]  873 	mov	_dim1_val,a
      00024C EF               [12]  874 	mov	a,r7
      00024D 34 FF            [12]  875 	addc	a,#0xff
      00024F F5*0D            [12]  876 	mov	(_dim1_val + 1),a
                                    877 ;	assignBit
      000251 C2 81            [12]  878 	clr	_P0_1
                                    879 ;	assignBit
      000253 C2 80            [12]  880 	clr	_P0_0
                                    881 ;	assignBit
      000255 D2 A6            [12]  882 	setb	_P2_6
      000257 80 28            [24]  883 	sjmp	00152$
      000259                        884 00151$:
                                    885 ;	Receiver.c:113: else if(dim1_val2){dim1_val2--;P0_1 =0;P0_0 =0;P2_6=0;}
      000259 E5*0E            [12]  886 	mov	a,_dim1_val2
      00025B 45*0F            [12]  887 	orl	a,(_dim1_val2 + 1)
      00025D 60 16            [24]  888 	jz	00148$
      00025F AE*0E            [24]  889 	mov	r6,_dim1_val2
      000261 AF*0F            [24]  890 	mov	r7,(_dim1_val2 + 1)
      000263 EE               [12]  891 	mov	a,r6
      000264 24 FF            [12]  892 	add	a,#0xff
      000266 F5*0E            [12]  893 	mov	_dim1_val2,a
      000268 EF               [12]  894 	mov	a,r7
      000269 34 FF            [12]  895 	addc	a,#0xff
      00026B F5*0F            [12]  896 	mov	(_dim1_val2 + 1),a
                                    897 ;	assignBit
      00026D C2 81            [12]  898 	clr	_P0_1
                                    899 ;	assignBit
      00026F C2 80            [12]  900 	clr	_P0_0
                                    901 ;	assignBit
      000271 C2 A6            [12]  902 	clr	_P2_6
      000273 80 0C            [24]  903 	sjmp	00152$
      000275                        904 00148$:
                                    905 ;	Receiver.c:115: else {dim1_val = dim_val;dim1_val2 = dim_val2;}
      000275 85*08*0C         [24]  906 	mov	_dim1_val,_dim_val
      000278 85*09*0D         [24]  907 	mov	(_dim1_val + 1),(_dim_val + 1)
      00027B 85*0A*0E         [24]  908 	mov	_dim1_val2,_dim_val2
      00027E 85*0B*0F         [24]  909 	mov	(_dim1_val2 + 1),(_dim_val2 + 1)
      000281                        910 00152$:
                                    911 ;	Receiver.c:117: if(auto_flag)
      000281 20*00 03         [24]  912 	jb	_auto_flag,00431$
      000284 02r04rED         [24]  913 	ljmp	00230$
      000287                        914 00431$:
                                    915 ;	Receiver.c:118: down_led=1;
                                    916 ;	assignBit
      000287 D2 A4            [12]  917 	setb	_P2_4
                                    918 ;	Receiver.c:119: break;
      000289 02r04rED         [24]  919 	ljmp	00230$
                                    920 ;	Receiver.c:120: case 6:		if(dim1_val)
      00028C                        921 00155$:
      00028C E5*0C            [12]  922 	mov	a,_dim1_val
      00028E 45*0D            [12]  923 	orl	a,(_dim1_val + 1)
      000290 60 16            [24]  924 	jz	00160$
                                    925 ;	Receiver.c:121: {dim1_val--;P0_1 =0;P0_0 =0;P2_6=1;}
      000292 AE*0C            [24]  926 	mov	r6,_dim1_val
      000294 AF*0D            [24]  927 	mov	r7,(_dim1_val + 1)
      000296 EE               [12]  928 	mov	a,r6
      000297 24 FF            [12]  929 	add	a,#0xff
      000299 F5*0C            [12]  930 	mov	_dim1_val,a
      00029B EF               [12]  931 	mov	a,r7
      00029C 34 FF            [12]  932 	addc	a,#0xff
      00029E F5*0D            [12]  933 	mov	(_dim1_val + 1),a
                                    934 ;	assignBit
      0002A0 C2 81            [12]  935 	clr	_P0_1
                                    936 ;	assignBit
      0002A2 C2 80            [12]  937 	clr	_P0_0
                                    938 ;	assignBit
      0002A4 D2 A6            [12]  939 	setb	_P2_6
      0002A6 80 28            [24]  940 	sjmp	00161$
      0002A8                        941 00160$:
                                    942 ;	Receiver.c:123: else if(dim1_val2){dim1_val2--;P0_1 =0;P0_0 =0;P2_6=0;}
      0002A8 E5*0E            [12]  943 	mov	a,_dim1_val2
      0002AA 45*0F            [12]  944 	orl	a,(_dim1_val2 + 1)
      0002AC 60 16            [24]  945 	jz	00157$
      0002AE AE*0E            [24]  946 	mov	r6,_dim1_val2
      0002B0 AF*0F            [24]  947 	mov	r7,(_dim1_val2 + 1)
      0002B2 EE               [12]  948 	mov	a,r6
      0002B3 24 FF            [12]  949 	add	a,#0xff
      0002B5 F5*0E            [12]  950 	mov	_dim1_val2,a
      0002B7 EF               [12]  951 	mov	a,r7
      0002B8 34 FF            [12]  952 	addc	a,#0xff
      0002BA F5*0F            [12]  953 	mov	(_dim1_val2 + 1),a
                                    954 ;	assignBit
      0002BC C2 81            [12]  955 	clr	_P0_1
                                    956 ;	assignBit
      0002BE C2 80            [12]  957 	clr	_P0_0
                                    958 ;	assignBit
      0002C0 C2 A6            [12]  959 	clr	_P2_6
      0002C2 80 0C            [24]  960 	sjmp	00161$
      0002C4                        961 00157$:
                                    962 ;	Receiver.c:125: else {dim1_val = dim_val;dim1_val2 = dim_val2;}
      0002C4 85*08*0C         [24]  963 	mov	_dim1_val,_dim_val
      0002C7 85*09*0D         [24]  964 	mov	(_dim1_val + 1),(_dim_val + 1)
      0002CA 85*0A*0E         [24]  965 	mov	_dim1_val2,_dim_val2
      0002CD 85*0B*0F         [24]  966 	mov	(_dim1_val2 + 1),(_dim_val2 + 1)
      0002D0                        967 00161$:
                                    968 ;	Receiver.c:127: if(auto_flag)
      0002D0 20*00 03         [24]  969 	jb	_auto_flag,00434$
      0002D3 02r04rED         [24]  970 	ljmp	00230$
      0002D6                        971 00434$:
                                    972 ;	Receiver.c:128: down_led=1;
                                    973 ;	assignBit
      0002D6 D2 A4            [12]  974 	setb	_P2_4
                                    975 ;	Receiver.c:129: break;
      0002D8 02r04rED         [24]  976 	ljmp	00230$
                                    977 ;	Receiver.c:130: case 7:		if(dim1_val)
      0002DB                        978 00164$:
      0002DB E5*0C            [12]  979 	mov	a,_dim1_val
      0002DD 45*0D            [12]  980 	orl	a,(_dim1_val + 1)
      0002DF 60 17            [24]  981 	jz	00169$
                                    982 ;	Receiver.c:131: {dim1_val--;P0_1 =0;P0_0 =1;P2_6=0;}
      0002E1 AE*0C            [24]  983 	mov	r6,_dim1_val
      0002E3 AF*0D            [24]  984 	mov	r7,(_dim1_val + 1)
      0002E5 EE               [12]  985 	mov	a,r6
      0002E6 24 FF            [12]  986 	add	a,#0xff
      0002E8 F5*0C            [12]  987 	mov	_dim1_val,a
      0002EA EF               [12]  988 	mov	a,r7
      0002EB 34 FF            [12]  989 	addc	a,#0xff
      0002ED F5*0D            [12]  990 	mov	(_dim1_val + 1),a
                                    991 ;	assignBit
      0002EF C2 81            [12]  992 	clr	_P0_1
                                    993 ;	assignBit
      0002F1 D2 80            [12]  994 	setb	_P0_0
                                    995 ;	assignBit
      0002F3 C2 A6            [12]  996 	clr	_P2_6
      0002F5 02r04rED         [24]  997 	ljmp	00230$
      0002F8                        998 00169$:
                                    999 ;	Receiver.c:133: else if(dim1_val2){dim1_val2--;P0_1 =0;P0_0 =0;P2_6=0;}
      0002F8 E5*0E            [12] 1000 	mov	a,_dim1_val2
      0002FA 45*0F            [12] 1001 	orl	a,(_dim1_val2 + 1)
      0002FC 60 17            [24] 1002 	jz	00166$
      0002FE AE*0E            [24] 1003 	mov	r6,_dim1_val2
      000300 AF*0F            [24] 1004 	mov	r7,(_dim1_val2 + 1)
      000302 EE               [12] 1005 	mov	a,r6
      000303 24 FF            [12] 1006 	add	a,#0xff
      000305 F5*0E            [12] 1007 	mov	_dim1_val2,a
      000307 EF               [12] 1008 	mov	a,r7
      000308 34 FF            [12] 1009 	addc	a,#0xff
      00030A F5*0F            [12] 1010 	mov	(_dim1_val2 + 1),a
                                   1011 ;	assignBit
      00030C C2 81            [12] 1012 	clr	_P0_1
                                   1013 ;	assignBit
      00030E C2 80            [12] 1014 	clr	_P0_0
                                   1015 ;	assignBit
      000310 C2 A6            [12] 1016 	clr	_P2_6
      000312 02r04rED         [24] 1017 	ljmp	00230$
      000315                       1018 00166$:
                                   1019 ;	Receiver.c:135: else {dim1_val = dim_val;dim1_val2 = dim_val2;}
      000315 85*08*0C         [24] 1020 	mov	_dim1_val,_dim_val
      000318 85*09*0D         [24] 1021 	mov	(_dim1_val + 1),(_dim_val + 1)
      00031B 85*0A*0E         [24] 1022 	mov	_dim1_val2,_dim_val2
      00031E 85*0B*0F         [24] 1023 	mov	(_dim1_val2 + 1),(_dim_val2 + 1)
                                   1024 ;	Receiver.c:136: break;
      000321 02r04rED         [24] 1025 	ljmp	00230$
                                   1026 ;	Receiver.c:137: case 8:		if(dim1_val)
      000324                       1027 00171$:
      000324 E5*0C            [12] 1028 	mov	a,_dim1_val
      000326 45*0D            [12] 1029 	orl	a,(_dim1_val + 1)
      000328 60 16            [24] 1030 	jz	00176$
                                   1031 ;	Receiver.c:138: {dim1_val--;P0_1 =1;P0_0 =0;P2_6=0;}
      00032A AE*0C            [24] 1032 	mov	r6,_dim1_val
      00032C AF*0D            [24] 1033 	mov	r7,(_dim1_val + 1)
      00032E EE               [12] 1034 	mov	a,r6
      00032F 24 FF            [12] 1035 	add	a,#0xff
      000331 F5*0C            [12] 1036 	mov	_dim1_val,a
      000333 EF               [12] 1037 	mov	a,r7
      000334 34 FF            [12] 1038 	addc	a,#0xff
      000336 F5*0D            [12] 1039 	mov	(_dim1_val + 1),a
                                   1040 ;	assignBit
      000338 D2 81            [12] 1041 	setb	_P0_1
                                   1042 ;	assignBit
      00033A C2 80            [12] 1043 	clr	_P0_0
                                   1044 ;	assignBit
      00033C C2 A6            [12] 1045 	clr	_P2_6
      00033E 80 28            [24] 1046 	sjmp	00177$
      000340                       1047 00176$:
                                   1048 ;	Receiver.c:140: else if(dim1_val2){dim1_val2--;P0_1 =0;P0_0 =0;P2_6=0;}
      000340 E5*0E            [12] 1049 	mov	a,_dim1_val2
      000342 45*0F            [12] 1050 	orl	a,(_dim1_val2 + 1)
      000344 60 16            [24] 1051 	jz	00173$
      000346 AE*0E            [24] 1052 	mov	r6,_dim1_val2
      000348 AF*0F            [24] 1053 	mov	r7,(_dim1_val2 + 1)
      00034A EE               [12] 1054 	mov	a,r6
      00034B 24 FF            [12] 1055 	add	a,#0xff
      00034D F5*0E            [12] 1056 	mov	_dim1_val2,a
      00034F EF               [12] 1057 	mov	a,r7
      000350 34 FF            [12] 1058 	addc	a,#0xff
      000352 F5*0F            [12] 1059 	mov	(_dim1_val2 + 1),a
                                   1060 ;	assignBit
      000354 C2 81            [12] 1061 	clr	_P0_1
                                   1062 ;	assignBit
      000356 C2 80            [12] 1063 	clr	_P0_0
                                   1064 ;	assignBit
      000358 C2 A6            [12] 1065 	clr	_P2_6
      00035A 80 0C            [24] 1066 	sjmp	00177$
      00035C                       1067 00173$:
                                   1068 ;	Receiver.c:142: else {dim1_val = dim_val;dim1_val2 = dim_val2;}
      00035C 85*08*0C         [24] 1069 	mov	_dim1_val,_dim_val
      00035F 85*09*0D         [24] 1070 	mov	(_dim1_val + 1),(_dim_val + 1)
      000362 85*0A*0E         [24] 1071 	mov	_dim1_val2,_dim_val2
      000365 85*0B*0F         [24] 1072 	mov	(_dim1_val2 + 1),(_dim_val2 + 1)
      000368                       1073 00177$:
                                   1074 ;	Receiver.c:144: if(auto_flag)
      000368 20*00 03         [24] 1075 	jb	_auto_flag,00439$
      00036B 02r04rED         [24] 1076 	ljmp	00230$
      00036E                       1077 00439$:
                                   1078 ;	Receiver.c:145: up_led=1;
                                   1079 ;	assignBit
      00036E D2 A7            [12] 1080 	setb	_P2_7
                                   1081 ;	Receiver.c:146: break;
      000370 02r04rED         [24] 1082 	ljmp	00230$
                                   1083 ;	Receiver.c:147: case 9:		if(dim1_val)
      000373                       1084 00180$:
      000373 E5*0C            [12] 1085 	mov	a,_dim1_val
      000375 45*0D            [12] 1086 	orl	a,(_dim1_val + 1)
      000377 60 16            [24] 1087 	jz	00185$
                                   1088 ;	Receiver.c:148: {dim1_val--;P0_1 =0;P0_0 =0;P2_6=1;}
      000379 AE*0C            [24] 1089 	mov	r6,_dim1_val
      00037B AF*0D            [24] 1090 	mov	r7,(_dim1_val + 1)
      00037D EE               [12] 1091 	mov	a,r6
      00037E 24 FF            [12] 1092 	add	a,#0xff
      000380 F5*0C            [12] 1093 	mov	_dim1_val,a
      000382 EF               [12] 1094 	mov	a,r7
      000383 34 FF            [12] 1095 	addc	a,#0xff
      000385 F5*0D            [12] 1096 	mov	(_dim1_val + 1),a
                                   1097 ;	assignBit
      000387 C2 81            [12] 1098 	clr	_P0_1
                                   1099 ;	assignBit
      000389 C2 80            [12] 1100 	clr	_P0_0
                                   1101 ;	assignBit
      00038B D2 A6            [12] 1102 	setb	_P2_6
      00038D 80 28            [24] 1103 	sjmp	00186$
      00038F                       1104 00185$:
                                   1105 ;	Receiver.c:150: else if(dim1_val2){dim1_val2--;P0_1 =0;P0_0 =0;P2_6=0;}
      00038F E5*0E            [12] 1106 	mov	a,_dim1_val2
      000391 45*0F            [12] 1107 	orl	a,(_dim1_val2 + 1)
      000393 60 16            [24] 1108 	jz	00182$
      000395 AE*0E            [24] 1109 	mov	r6,_dim1_val2
      000397 AF*0F            [24] 1110 	mov	r7,(_dim1_val2 + 1)
      000399 EE               [12] 1111 	mov	a,r6
      00039A 24 FF            [12] 1112 	add	a,#0xff
      00039C F5*0E            [12] 1113 	mov	_dim1_val2,a
      00039E EF               [12] 1114 	mov	a,r7
      00039F 34 FF            [12] 1115 	addc	a,#0xff
      0003A1 F5*0F            [12] 1116 	mov	(_dim1_val2 + 1),a
                                   1117 ;	assignBit
      0003A3 C2 81            [12] 1118 	clr	_P0_1
                                   1119 ;	assignBit
      0003A5 C2 80            [12] 1120 	clr	_P0_0
                                   1121 ;	assignBit
      0003A7 C2 A6            [12] 1122 	clr	_P2_6
      0003A9 80 0C            [24] 1123 	sjmp	00186$
      0003AB                       1124 00182$:
                                   1125 ;	Receiver.c:152: else {dim1_val = dim_val;dim1_val2 = dim_val2;}
      0003AB 85*08*0C         [24] 1126 	mov	_dim1_val,_dim_val
      0003AE 85*09*0D         [24] 1127 	mov	(_dim1_val + 1),(_dim_val + 1)
      0003B1 85*0A*0E         [24] 1128 	mov	_dim1_val2,_dim_val2
      0003B4 85*0B*0F         [24] 1129 	mov	(_dim1_val2 + 1),(_dim_val2 + 1)
      0003B7                       1130 00186$:
                                   1131 ;	Receiver.c:154: if(auto_flag)
      0003B7 20*00 03         [24] 1132 	jb	_auto_flag,00442$
      0003BA 02r04rED         [24] 1133 	ljmp	00230$
      0003BD                       1134 00442$:
                                   1135 ;	Receiver.c:155: down_led=1;
                                   1136 ;	assignBit
      0003BD D2 A4            [12] 1137 	setb	_P2_4
                                   1138 ;	Receiver.c:156: break;
      0003BF 02r04rED         [24] 1139 	ljmp	00230$
                                   1140 ;	Receiver.c:158: }	
      0003C2                       1141 00226$:
                                   1142 ;	Receiver.c:162: else if((timerCount > time_delay) &&(timerCount<time_delay*60)) // count for LED-ON delay
      0003C2 C3               [12] 1143 	clr	c
      0003C3 E5*06            [12] 1144 	mov	a,_time_delay
      0003C5 95*02            [12] 1145 	subb	a,_timerCount
      0003C7 E5*07            [12] 1146 	mov	a,(_time_delay + 1)
      0003C9 64 80            [12] 1147 	xrl	a,#0x80
      0003CB 85*03 F0         [24] 1148 	mov	b,(_timerCount + 1)
      0003CE 63 F0 80         [24] 1149 	xrl	b,#0x80
      0003D1 95 F0            [12] 1150 	subb	a,b
      0003D3 40 03            [24] 1151 	jc	00443$
      0003D5 02r04rE8         [24] 1152 	ljmp	00222$
      0003D8                       1153 00443$:
      0003D8 85*06*00         [24] 1154 	mov	__mulint_PARM_2,_time_delay
      0003DB 85*07*01         [24] 1155 	mov	(__mulint_PARM_2 + 1),(_time_delay + 1)
      0003DE 90 00 3C         [24] 1156 	mov	dptr,#0x003c
      0003E1 12r00r00         [24] 1157 	lcall	__mulint
      0003E4 AE 82            [24] 1158 	mov	r6,dpl
      0003E6 AF 83            [24] 1159 	mov	r7,dph
      0003E8 C3               [12] 1160 	clr	c
      0003E9 E5*02            [12] 1161 	mov	a,_timerCount
      0003EB 9E               [12] 1162 	subb	a,r6
      0003EC E5*03            [12] 1163 	mov	a,(_timerCount + 1)
      0003EE 64 80            [12] 1164 	xrl	a,#0x80
      0003F0 8F F0            [24] 1165 	mov	b,r7
      0003F2 63 F0 80         [24] 1166 	xrl	b,#0x80
      0003F5 95 F0            [12] 1167 	subb	a,b
      0003F7 40 03            [24] 1168 	jc	00444$
      0003F9 02r04rE8         [24] 1169 	ljmp	00222$
      0003FC                       1170 00444$:
                                   1171 ;	Receiver.c:164: switch(state)
      0003FC E5*11            [12] 1172 	mov	a,(_state + 1)
      0003FE 30 E7 03         [24] 1173 	jnb	acc.7,00445$
      000401 02r04rED         [24] 1174 	ljmp	00230$
      000404                       1175 00445$:
      000404 C3               [12] 1176 	clr	c
      000405 74 09            [12] 1177 	mov	a,#0x09
      000407 95*10            [12] 1178 	subb	a,_state
      000409 74 80            [12] 1179 	mov	a,#(0x00 ^ 0x80)
      00040B 85*11 F0         [24] 1180 	mov	b,(_state + 1)
      00040E 63 F0 80         [24] 1181 	xrl	b,#0x80
      000411 95 F0            [12] 1182 	subb	a,b
      000413 50 03            [24] 1183 	jnc	00446$
      000415 02r04rED         [24] 1184 	ljmp	00230$
      000418                       1185 00446$:
      000418 E5*10            [12] 1186 	mov	a,_state
      00041A 24 0B            [12] 1187 	add	a,#(00447$-3-.)
      00041C 83               [24] 1188 	movc	a,@a+pc
      00041D F5 82            [12] 1189 	mov	dpl,a
      00041F E5*10            [12] 1190 	mov	a,_state
      000421 24 0E            [12] 1191 	add	a,#(00448$-3-.)
      000423 83               [24] 1192 	movc	a,@a+pc
      000424 F5 83            [12] 1193 	mov	dph,a
      000426 E4               [12] 1194 	clr	a
      000427 73               [24] 1195 	jmp	@a+dptr
      000428                       1196 00447$:
      000428r3C                    1197 	.db	00191$
      000429r4E                    1198 	.db	00201$
      00042Ar41                    1199 	.db	00200$
      00042Br41                    1200 	.db	00200$
      00042Cr41                    1201 	.db	00200$
      00042Dr41                    1202 	.db	00200$
      00042Er9B                    1203 	.db	00210$
      00042Fr41                    1204 	.db	00200$
      000430r41                    1205 	.db	00200$
      000431r41                    1206 	.db	00200$
      000432                       1207 00448$:
      000432s04                    1208 	.db	00191$>>8
      000433s04                    1209 	.db	00201$>>8
      000434s04                    1210 	.db	00200$>>8
      000435s04                    1211 	.db	00200$>>8
      000436s04                    1212 	.db	00200$>>8
      000437s04                    1213 	.db	00200$>>8
      000438s04                    1214 	.db	00210$>>8
      000439s04                    1215 	.db	00200$>>8
      00043As04                    1216 	.db	00200$>>8
      00043Bs04                    1217 	.db	00200$>>8
                                   1218 ;	Receiver.c:166: case 0:	if(auto_flag)	auto_led=0;
      00043C                       1219 00191$:
      00043C 30*00 02         [24] 1220 	jnb	_auto_flag,00200$
                                   1221 ;	assignBit
      00043F C2 A1            [12] 1222 	clr	_P2_1
                                   1223 ;	Receiver.c:173: case 9:P0_1 =0;P0_0 =0;P2_6=0;up_led=0;down_led=0;break;
      000441                       1224 00200$:
                                   1225 ;	assignBit
      000441 C2 81            [12] 1226 	clr	_P0_1
                                   1227 ;	assignBit
      000443 C2 80            [12] 1228 	clr	_P0_0
                                   1229 ;	assignBit
      000445 C2 A6            [12] 1230 	clr	_P2_6
                                   1231 ;	assignBit
      000447 C2 A7            [12] 1232 	clr	_P2_7
                                   1233 ;	assignBit
      000449 C2 A4            [12] 1234 	clr	_P2_4
      00044B 02r04rED         [24] 1235 	ljmp	00230$
                                   1236 ;	Receiver.c:174: case 1:	if(dim1_val)
      00044E                       1237 00201$:
      00044E E5*0C            [12] 1238 	mov	a,_dim1_val
      000450 45*0D            [12] 1239 	orl	a,(_dim1_val + 1)
      000452 60 16            [24] 1240 	jz	00206$
                                   1241 ;	Receiver.c:175: {dim1_val--;P0_1 =1;P0_0 =0;P2_6=0;}
      000454 AE*0C            [24] 1242 	mov	r6,_dim1_val
      000456 AF*0D            [24] 1243 	mov	r7,(_dim1_val + 1)
      000458 EE               [12] 1244 	mov	a,r6
      000459 24 FF            [12] 1245 	add	a,#0xff
      00045B F5*0C            [12] 1246 	mov	_dim1_val,a
      00045D EF               [12] 1247 	mov	a,r7
      00045E 34 FF            [12] 1248 	addc	a,#0xff
      000460 F5*0D            [12] 1249 	mov	(_dim1_val + 1),a
                                   1250 ;	assignBit
      000462 D2 81            [12] 1251 	setb	_P0_1
                                   1252 ;	assignBit
      000464 C2 80            [12] 1253 	clr	_P0_0
                                   1254 ;	assignBit
      000466 C2 A6            [12] 1255 	clr	_P2_6
      000468 80 28            [24] 1256 	sjmp	00207$
      00046A                       1257 00206$:
                                   1258 ;	Receiver.c:177: else if(dim1_val2){dim1_val2--;P0_1 =0;P0_0 =0;P2_6=0;}
      00046A E5*0E            [12] 1259 	mov	a,_dim1_val2
      00046C 45*0F            [12] 1260 	orl	a,(_dim1_val2 + 1)
      00046E 60 16            [24] 1261 	jz	00203$
      000470 AE*0E            [24] 1262 	mov	r6,_dim1_val2
      000472 AF*0F            [24] 1263 	mov	r7,(_dim1_val2 + 1)
      000474 EE               [12] 1264 	mov	a,r6
      000475 24 FF            [12] 1265 	add	a,#0xff
      000477 F5*0E            [12] 1266 	mov	_dim1_val2,a
      000479 EF               [12] 1267 	mov	a,r7
      00047A 34 FF            [12] 1268 	addc	a,#0xff
      00047C F5*0F            [12] 1269 	mov	(_dim1_val2 + 1),a
                                   1270 ;	assignBit
      00047E C2 81            [12] 1271 	clr	_P0_1
                                   1272 ;	assignBit
      000480 C2 80            [12] 1273 	clr	_P0_0
                                   1274 ;	assignBit
      000482 C2 A6            [12] 1275 	clr	_P2_6
      000484 80 0C            [24] 1276 	sjmp	00207$
      000486                       1277 00203$:
                                   1278 ;	Receiver.c:179: else {dim1_val = dim_val;dim1_val2 = dim_val2;}
      000486 85*08*0C         [24] 1279 	mov	_dim1_val,_dim_val
      000489 85*09*0D         [24] 1280 	mov	(_dim1_val + 1),(_dim_val + 1)
      00048C 85*0A*0E         [24] 1281 	mov	_dim1_val2,_dim_val2
      00048F 85*0B*0F         [24] 1282 	mov	(_dim1_val2 + 1),(_dim_val2 + 1)
      000492                       1283 00207$:
                                   1284 ;	Receiver.c:180: if(auto_flag)up_led=1;down_led=0;break;
      000492 30*00 02         [24] 1285 	jnb	_auto_flag,00209$
                                   1286 ;	assignBit
      000495 D2 A7            [12] 1287 	setb	_P2_7
      000497                       1288 00209$:
                                   1289 ;	assignBit
      000497 C2 A4            [12] 1290 	clr	_P2_4
                                   1291 ;	Receiver.c:181: case 6:	if(dim1_val)
      000499 80 52            [24] 1292 	sjmp	00230$
      00049B                       1293 00210$:
      00049B E5*0C            [12] 1294 	mov	a,_dim1_val
      00049D 45*0D            [12] 1295 	orl	a,(_dim1_val + 1)
      00049F 60 16            [24] 1296 	jz	00215$
                                   1297 ;	Receiver.c:182: {dim1_val--;P0_1 =0;P0_0 =0;P2_6=1;}
      0004A1 AE*0C            [24] 1298 	mov	r6,_dim1_val
      0004A3 AF*0D            [24] 1299 	mov	r7,(_dim1_val + 1)
      0004A5 EE               [12] 1300 	mov	a,r6
      0004A6 24 FF            [12] 1301 	add	a,#0xff
      0004A8 F5*0C            [12] 1302 	mov	_dim1_val,a
      0004AA EF               [12] 1303 	mov	a,r7
      0004AB 34 FF            [12] 1304 	addc	a,#0xff
      0004AD F5*0D            [12] 1305 	mov	(_dim1_val + 1),a
                                   1306 ;	assignBit
      0004AF C2 81            [12] 1307 	clr	_P0_1
                                   1308 ;	assignBit
      0004B1 C2 80            [12] 1309 	clr	_P0_0
                                   1310 ;	assignBit
      0004B3 D2 A6            [12] 1311 	setb	_P2_6
      0004B5 80 28            [24] 1312 	sjmp	00216$
      0004B7                       1313 00215$:
                                   1314 ;	Receiver.c:184: else if(dim1_val2){dim1_val2--;P0_1 =0;P0_0 =0;P2_6=0;}
      0004B7 E5*0E            [12] 1315 	mov	a,_dim1_val2
      0004B9 45*0F            [12] 1316 	orl	a,(_dim1_val2 + 1)
      0004BB 60 16            [24] 1317 	jz	00212$
      0004BD AE*0E            [24] 1318 	mov	r6,_dim1_val2
      0004BF AF*0F            [24] 1319 	mov	r7,(_dim1_val2 + 1)
      0004C1 EE               [12] 1320 	mov	a,r6
      0004C2 24 FF            [12] 1321 	add	a,#0xff
      0004C4 F5*0E            [12] 1322 	mov	_dim1_val2,a
      0004C6 EF               [12] 1323 	mov	a,r7
      0004C7 34 FF            [12] 1324 	addc	a,#0xff
      0004C9 F5*0F            [12] 1325 	mov	(_dim1_val2 + 1),a
                                   1326 ;	assignBit
      0004CB C2 81            [12] 1327 	clr	_P0_1
                                   1328 ;	assignBit
      0004CD C2 80            [12] 1329 	clr	_P0_0
                                   1330 ;	assignBit
      0004CF C2 A6            [12] 1331 	clr	_P2_6
      0004D1 80 0C            [24] 1332 	sjmp	00216$
      0004D3                       1333 00212$:
                                   1334 ;	Receiver.c:186: else {dim1_val = dim_val;dim1_val2 = dim_val2;}
      0004D3 85*08*0C         [24] 1335 	mov	_dim1_val,_dim_val
      0004D6 85*09*0D         [24] 1336 	mov	(_dim1_val + 1),(_dim_val + 1)
      0004D9 85*0A*0E         [24] 1337 	mov	_dim1_val2,_dim_val2
      0004DC 85*0B*0F         [24] 1338 	mov	(_dim1_val2 + 1),(_dim_val2 + 1)
      0004DF                       1339 00216$:
                                   1340 ;	Receiver.c:187: up_led=0;if(auto_flag)down_led=1;break;
                                   1341 ;	assignBit
      0004DF C2 A7            [12] 1342 	clr	_P2_7
      0004E1 30*00 09         [24] 1343 	jnb	_auto_flag,00230$
                                   1344 ;	assignBit
      0004E4 D2 A4            [12] 1345 	setb	_P2_4
                                   1346 ;	Receiver.c:189: }
      0004E6 80 05            [24] 1347 	sjmp	00230$
      0004E8                       1348 00222$:
                                   1349 ;	Receiver.c:193: {timerCount = 0;}
      0004E8 E4               [12] 1350 	clr	a
      0004E9 F5*02            [12] 1351 	mov	_timerCount,a
      0004EB F5*03            [12] 1352 	mov	(_timerCount + 1),a
      0004ED                       1353 00230$:
                                   1354 ;	Receiver.c:195: } //timer end
      0004ED D0 D0            [24] 1355 	pop	psw
      0004EF D0 00            [24] 1356 	pop	(0+0)
      0004F1 D0 01            [24] 1357 	pop	(0+1)
      0004F3 D0 02            [24] 1358 	pop	(0+2)
      0004F5 D0 03            [24] 1359 	pop	(0+3)
      0004F7 D0 04            [24] 1360 	pop	(0+4)
      0004F9 D0 05            [24] 1361 	pop	(0+5)
      0004FB D0 06            [24] 1362 	pop	(0+6)
      0004FD D0 07            [24] 1363 	pop	(0+7)
      0004FF D0 83            [24] 1364 	pop	dph
      000501 D0 82            [24] 1365 	pop	dpl
      000503 D0 F0            [24] 1366 	pop	b
      000505 D0 E0            [24] 1367 	pop	acc
      000507 D0*00            [24] 1368 	pop	bits
      000509 32               [24] 1369 	reti
                                   1370 ;------------------------------------------------------------
                                   1371 ;Allocation info for local variables in function 'main'
                                   1372 ;------------------------------------------------------------
                                   1373 ;	Receiver.c:198: void main()
                                   1374 ;	-----------------------------------------
                                   1375 ;	 function main
                                   1376 ;	-----------------------------------------
      00050A                       1377 _main:
                                   1378 ;	Receiver.c:200: state=20;
      00050A 75*10 14         [24] 1379 	mov	_state,#0x14
      00050D 75*11 00         [24] 1380 	mov	(_state + 1),#0x00
                                   1381 ;	Receiver.c:201: pwr_out=0;
                                   1382 ;	assignBit
      000510 C2 87            [12] 1383 	clr	_P0_7
                                   1384 ;	Receiver.c:202: InitTimer0();
      000512 12r06rDF         [24] 1385 	lcall	_InitTimer0
                                   1386 ;	Receiver.c:203: EA=1;
                                   1387 ;	assignBit
      000515 D2 AF            [12] 1388 	setb	_EA
                                   1389 ;	Receiver.c:204: startup();
      000517 12r05r2B         [24] 1390 	lcall	_startup
                                   1391 ;	Receiver.c:205: start=1;
      00051A 75*00 01         [24] 1392 	mov	_start,#0x01
                                   1393 ;	Receiver.c:206: UART_Init();
      00051D 12r05rB3         [24] 1394 	lcall	_UART_Init
                                   1395 ;	Receiver.c:207: handshake();
      000520 12r05rC8         [24] 1396 	lcall	_handshake
                                   1397 ;	Receiver.c:208: while(1)
      000523                       1398 00102$:
                                   1399 ;	Receiver.c:211: check_switches();
      000523 12r06rED         [24] 1400 	lcall	_check_switches
                                   1401 ;	Receiver.c:212: check_data();
      000526 12r05rF5         [24] 1402 	lcall	_check_data
                                   1403 ;	Receiver.c:214: } //main
      000529 80 F8            [24] 1404 	sjmp	00102$
                                   1405 ;------------------------------------------------------------
                                   1406 ;Allocation info for local variables in function 'startup'
                                   1407 ;------------------------------------------------------------
                                   1408 ;	Receiver.c:217: void startup()
                                   1409 ;	-----------------------------------------
                                   1410 ;	 function startup
                                   1411 ;	-----------------------------------------
      00052B                       1412 _startup:
                                   1413 ;	Receiver.c:219: P0=0x00;
      00052B 75 80 00         [24] 1414 	mov	_P0,#0x00
                                   1415 ;	Receiver.c:220: P2=0x00;
      00052E 75 A0 00         [24] 1416 	mov	_P2,#0x00
                                   1417 ;	Receiver.c:222: pwr_key=1;
                                   1418 ;	assignBit
      000531 D2 97            [12] 1419 	setb	_P1_7
                                   1420 ;	Receiver.c:223: dim_key=1;
                                   1421 ;	assignBit
      000533 D2 94            [12] 1422 	setb	_P1_4
                                   1423 ;	Receiver.c:224: ac_key=1;
                                   1424 ;	assignBit
      000535 D2 93            [12] 1425 	setb	_P1_3
                                   1426 ;	Receiver.c:225: auto_key=1;
                                   1427 ;	assignBit
      000537 D2 92            [12] 1428 	setb	_P1_2
                                   1429 ;	Receiver.c:227: pwr_out=0;
                                   1430 ;	assignBit
      000539 C2 87            [12] 1431 	clr	_P0_7
                                   1432 ;	Receiver.c:228: rst_out=0;
                                   1433 ;	assignBit
      00053B C2 96            [12] 1434 	clr	_P1_6
                                   1435 ;	Receiver.c:230: pwr_led=0;
                                   1436 ;	assignBit
      00053D C2 A0            [12] 1437 	clr	_P2_0
                                   1438 ;	Receiver.c:231: auto_led=0;
                                   1439 ;	assignBit
      00053F C2 A1            [12] 1440 	clr	_P2_1
                                   1441 ;	Receiver.c:232: ac_led_up=0;
                                   1442 ;	assignBit
      000541 C2 A2            [12] 1443 	clr	_P2_2
                                   1444 ;	Receiver.c:233: ac_led_down=0;
                                   1445 ;	assignBit
      000543 C2 A3            [12] 1446 	clr	_P2_3
                                   1447 ;	Receiver.c:234: up_led=0;
                                   1448 ;	assignBit
      000545 C2 A7            [12] 1449 	clr	_P2_7
                                   1450 ;	Receiver.c:235: down_led=0;
                                   1451 ;	assignBit
      000547 C2 A4            [12] 1452 	clr	_P2_4
                                   1453 ;	Receiver.c:237: pwr_led=1;
                                   1454 ;	assignBit
      000549 D2 A0            [12] 1455 	setb	_P2_0
                                   1456 ;	Receiver.c:238: auto_led=0;
                                   1457 ;	assignBit
      00054B C2 A1            [12] 1458 	clr	_P2_1
                                   1459 ;	Receiver.c:239: ac_led_up=1;ac_led_down=0;
                                   1460 ;	assignBit
      00054D D2 A2            [12] 1461 	setb	_P2_2
                                   1462 ;	assignBit
      00054F C2 A3            [12] 1463 	clr	_P2_3
                                   1464 ;	Receiver.c:240: auto_flag = 0;
                                   1465 ;	assignBit
      000551 C2*00            [12] 1466 	clr	_auto_flag
                                   1467 ;	Receiver.c:242: P0_1 =1;P0_0 =1;P2_6=1;
                                   1468 ;	assignBit
      000553 D2 81            [12] 1469 	setb	_P0_1
                                   1470 ;	assignBit
      000555 D2 80            [12] 1471 	setb	_P0_0
                                   1472 ;	assignBit
      000557 D2 A6            [12] 1473 	setb	_P2_6
                                   1474 ;	Receiver.c:243: delay();delay();
      000559 12r05r8A         [24] 1475 	lcall	_delay
      00055C 12r05r8A         [24] 1476 	lcall	_delay
                                   1477 ;	Receiver.c:244: P0_1 =0;P0_0 =0;P2_6=1;
                                   1478 ;	assignBit
      00055F C2 81            [12] 1479 	clr	_P0_1
                                   1480 ;	assignBit
      000561 C2 80            [12] 1481 	clr	_P0_0
                                   1482 ;	assignBit
      000563 D2 A6            [12] 1483 	setb	_P2_6
                                   1484 ;	Receiver.c:245: delay();delay();
      000565 12r05r8A         [24] 1485 	lcall	_delay
      000568 12r05r8A         [24] 1486 	lcall	_delay
                                   1487 ;	Receiver.c:246: P0_1 =0;P0_0 =1;P2_6=0;
                                   1488 ;	assignBit
      00056B C2 81            [12] 1489 	clr	_P0_1
                                   1490 ;	assignBit
      00056D D2 80            [12] 1491 	setb	_P0_0
                                   1492 ;	assignBit
      00056F C2 A6            [12] 1493 	clr	_P2_6
                                   1494 ;	Receiver.c:247: delay();delay();
      000571 12r05r8A         [24] 1495 	lcall	_delay
      000574 12r05r8A         [24] 1496 	lcall	_delay
                                   1497 ;	Receiver.c:248: P0_1 =1;P0_0 =0;P2_6=0;
                                   1498 ;	assignBit
      000577 D2 81            [12] 1499 	setb	_P0_1
                                   1500 ;	assignBit
      000579 C2 80            [12] 1501 	clr	_P0_0
                                   1502 ;	assignBit
      00057B C2 A6            [12] 1503 	clr	_P2_6
                                   1504 ;	Receiver.c:249: delay();delay();
      00057D 12r05r8A         [24] 1505 	lcall	_delay
      000580 12r05r8A         [24] 1506 	lcall	_delay
                                   1507 ;	Receiver.c:250: P0_1 =0;P0_0 =0;P2_6=0;
                                   1508 ;	assignBit
      000583 C2 81            [12] 1509 	clr	_P0_1
                                   1510 ;	assignBit
      000585 C2 80            [12] 1511 	clr	_P0_0
                                   1512 ;	assignBit
      000587 C2 A6            [12] 1513 	clr	_P2_6
                                   1514 ;	Receiver.c:251: }
      000589 22               [24] 1515 	ret
                                   1516 ;------------------------------------------------------------
                                   1517 ;Allocation info for local variables in function 'delay'
                                   1518 ;------------------------------------------------------------
                                   1519 ;i                         Allocated to registers r6 r7 
                                   1520 ;j                         Allocated to registers r4 r5 
                                   1521 ;------------------------------------------------------------
                                   1522 ;	Receiver.c:253: void delay()
                                   1523 ;	-----------------------------------------
                                   1524 ;	 function delay
                                   1525 ;	-----------------------------------------
      00058A                       1526 _delay:
                                   1527 ;	Receiver.c:256: for(i=0;i<0x33;i++)
      00058A 7E 00            [12] 1528 	mov	r6,#0x00
      00058C 7F 00            [12] 1529 	mov	r7,#0x00
      00058E                       1530 00106$:
                                   1531 ;	Receiver.c:257: for(j=0;j<0xff;j++);
      00058E 7C FF            [12] 1532 	mov	r4,#0xff
      000590 7D 00            [12] 1533 	mov	r5,#0x00
      000592                       1534 00105$:
      000592 EC               [12] 1535 	mov	a,r4
      000593 24 FF            [12] 1536 	add	a,#0xff
      000595 FA               [12] 1537 	mov	r2,a
      000596 ED               [12] 1538 	mov	a,r5
      000597 34 FF            [12] 1539 	addc	a,#0xff
      000599 FB               [12] 1540 	mov	r3,a
      00059A 8A 04            [24] 1541 	mov	ar4,r2
      00059C 8B 05            [24] 1542 	mov	ar5,r3
      00059E EA               [12] 1543 	mov	a,r2
      00059F 4B               [12] 1544 	orl	a,r3
      0005A0 70 F0            [24] 1545 	jnz	00105$
                                   1546 ;	Receiver.c:256: for(i=0;i<0x33;i++)
      0005A2 0E               [12] 1547 	inc	r6
      0005A3 BE 00 01         [24] 1548 	cjne	r6,#0x00,00124$
      0005A6 0F               [12] 1549 	inc	r7
      0005A7                       1550 00124$:
      0005A7 C3               [12] 1551 	clr	c
      0005A8 EE               [12] 1552 	mov	a,r6
      0005A9 94 33            [12] 1553 	subb	a,#0x33
      0005AB EF               [12] 1554 	mov	a,r7
      0005AC 64 80            [12] 1555 	xrl	a,#0x80
      0005AE 94 80            [12] 1556 	subb	a,#0x80
      0005B0 40 DC            [24] 1557 	jc	00106$
                                   1558 ;	Receiver.c:258: }
      0005B2 22               [24] 1559 	ret
                                   1560 ;------------------------------------------------------------
                                   1561 ;Allocation info for local variables in function 'UART_Init'
                                   1562 ;------------------------------------------------------------
                                   1563 ;	Receiver.c:261: void UART_Init()
                                   1564 ;	-----------------------------------------
                                   1565 ;	 function UART_Init
                                   1566 ;	-----------------------------------------
      0005B3                       1567 _UART_Init:
                                   1568 ;	Receiver.c:263: TMOD = 0x20;		/* Timer 1, 8-bit auto reload mode */
      0005B3 75 89 20         [24] 1569 	mov	_TMOD,#0x20
                                   1570 ;	Receiver.c:264: TH1 = 0xFD;		/* Load value for 9600 baud rate */
      0005B6 75 8D FD         [24] 1571 	mov	_TH1,#0xfd
                                   1572 ;	Receiver.c:265: SCON = 0x50;		/* Mode 1, reception enable */
      0005B9 75 98 50         [24] 1573 	mov	_SCON,#0x50
                                   1574 ;	Receiver.c:266: TR1 = 1;		/* Start timer 1 */
                                   1575 ;	assignBit
      0005BC D2 8E            [12] 1576 	setb	_TR1
                                   1577 ;	Receiver.c:267: }
      0005BE 22               [24] 1578 	ret
                                   1579 ;------------------------------------------------------------
                                   1580 ;Allocation info for local variables in function 'Transmit_data'
                                   1581 ;------------------------------------------------------------
                                   1582 ;tx_data                   Allocated to registers 
                                   1583 ;------------------------------------------------------------
                                   1584 ;	Receiver.c:270: void Transmit_data(char tx_data)
                                   1585 ;	-----------------------------------------
                                   1586 ;	 function Transmit_data
                                   1587 ;	-----------------------------------------
      0005BF                       1588 _Transmit_data:
      0005BF 85 82 99         [24] 1589 	mov	_SBUF,dpl
                                   1590 ;	Receiver.c:273: while (TI==0);		/* Wait until stop bit transmit */
      0005C2                       1591 00101$:
                                   1592 ;	Receiver.c:274: TI = 0;			/* Clear TI flag */
                                   1593 ;	assignBit
      0005C2 10 99 02         [24] 1594 	jbc	_TI,00114$
      0005C5 80 FB            [24] 1595 	sjmp	00101$
      0005C7                       1596 00114$:
                                   1597 ;	Receiver.c:275: }
      0005C7 22               [24] 1598 	ret
                                   1599 ;------------------------------------------------------------
                                   1600 ;Allocation info for local variables in function 'handshake'
                                   1601 ;------------------------------------------------------------
                                   1602 ;	Receiver.c:278: void handshake()
                                   1603 ;	-----------------------------------------
                                   1604 ;	 function handshake
                                   1605 ;	-----------------------------------------
      0005C8                       1606 _handshake:
                                   1607 ;	Receiver.c:280: while(data_r!='y')
      0005C8                       1608 00101$:
      0005C8 74 79            [12] 1609 	mov	a,#0x79
      0005CA B5*01 02         [24] 1610 	cjne	a,_data_r,00114$
      0005CD 80 1D            [24] 1611 	sjmp	00103$
      0005CF                       1612 00114$:
                                   1613 ;	Receiver.c:282: state=20;
      0005CF 75*10 14         [24] 1614 	mov	_state,#0x14
      0005D2 75*11 00         [24] 1615 	mov	(_state + 1),#0x00
                                   1616 ;	Receiver.c:283: delay();
      0005D5 12r05r8A         [24] 1617 	lcall	_delay
                                   1618 ;	Receiver.c:284: delay();
      0005D8 12r05r8A         [24] 1619 	lcall	_delay
                                   1620 ;	Receiver.c:285: delay();
      0005DB 12r05r8A         [24] 1621 	lcall	_delay
                                   1622 ;	Receiver.c:286: Transmit_data('x');
      0005DE 75 82 78         [24] 1623 	mov	dpl,#0x78
      0005E1 12r05rBF         [24] 1624 	lcall	_Transmit_data
                                   1625 ;	Receiver.c:287: delay();
      0005E4 12r05r8A         [24] 1626 	lcall	_delay
                                   1627 ;	Receiver.c:288: data_r=SBUF;
      0005E7 85 99*01         [24] 1628 	mov	_data_r,_SBUF
      0005EA 80 DC            [24] 1629 	sjmp	00101$
      0005EC                       1630 00103$:
                                   1631 ;	Receiver.c:290: delay();
      0005EC 12r05r8A         [24] 1632 	lcall	_delay
                                   1633 ;	Receiver.c:291: Transmit_data('m');
      0005EF 75 82 6D         [24] 1634 	mov	dpl,#0x6d
                                   1635 ;	Receiver.c:292: }
      0005F2 02r05rBF         [24] 1636 	ljmp	_Transmit_data
                                   1637 ;------------------------------------------------------------
                                   1638 ;Allocation info for local variables in function 'check_data'
                                   1639 ;------------------------------------------------------------
                                   1640 ;	Receiver.c:294: void check_data()
                                   1641 ;	-----------------------------------------
                                   1642 ;	 function check_data
                                   1643 ;	-----------------------------------------
      0005F5                       1644 _check_data:
                                   1645 ;	Receiver.c:297: data_r = SBUF;		/* Load char in SBUF register */
      0005F5 85 99*01         [24] 1646 	mov	_data_r,_SBUF
                                   1647 ;	Receiver.c:298: RI = 0;			/* Clear TI flag */
                                   1648 ;	assignBit
      0005F8 C2 98            [12] 1649 	clr	_RI
                                   1650 ;	Receiver.c:299: if(data_r=='l')
      0005FA 74 6C            [12] 1651 	mov	a,#0x6c
      0005FC B5*01 0D         [24] 1652 	cjne	a,_data_r,00146$
                                   1653 ;	Receiver.c:301: time_delay=30;
      0005FF 75*06 1E         [24] 1654 	mov	_time_delay,#0x1e
                                   1655 ;	Receiver.c:302: state = 0;
      000602 E4               [12] 1656 	clr	a
      000603 F5*07            [12] 1657 	mov	(_time_delay + 1),a
      000605 F5*10            [12] 1658 	mov	_state,a
      000607 F5*11            [12] 1659 	mov	(_state + 1),a
                                   1660 ;	Receiver.c:303: auto_led=0;
                                   1661 ;	assignBit
      000609 C2 A1            [12] 1662 	clr	_P2_1
      00060B 22               [24] 1663 	ret
      00060C                       1664 00146$:
                                   1665 ;	Receiver.c:305: else if(data_r=='a')
      00060C 74 61            [12] 1666 	mov	a,#0x61
      00060E B5*01 13         [24] 1667 	cjne	a,_data_r,00143$
                                   1668 ;	Receiver.c:307: time_delay=20;
      000611 75*06 14         [24] 1669 	mov	_time_delay,#0x14
      000614 75*07 00         [24] 1670 	mov	(_time_delay + 1),#0x00
                                   1671 ;	Receiver.c:308: state = 1;
      000617 75*10 01         [24] 1672 	mov	_state,#0x01
      00061A 75*11 00         [24] 1673 	mov	(_state + 1),#0x00
                                   1674 ;	Receiver.c:309: if(auto_flag)	auto_led=1;
      00061D 20*00 01         [24] 1675 	jb	_auto_flag,00230$
      000620 22               [24] 1676 	ret
      000621                       1677 00230$:
                                   1678 ;	assignBit
      000621 D2 A1            [12] 1679 	setb	_P2_1
      000623 22               [24] 1680 	ret
      000624                       1681 00143$:
                                   1682 ;	Receiver.c:311: else if(data_r=='b')
      000624 74 62            [12] 1683 	mov	a,#0x62
      000626 B5*01 13         [24] 1684 	cjne	a,_data_r,00140$
                                   1685 ;	Receiver.c:313: time_delay=10;
      000629 75*06 0A         [24] 1686 	mov	_time_delay,#0x0a
      00062C 75*07 00         [24] 1687 	mov	(_time_delay + 1),#0x00
                                   1688 ;	Receiver.c:314: state = 2;
      00062F 75*10 02         [24] 1689 	mov	_state,#0x02
      000632 75*11 00         [24] 1690 	mov	(_state + 1),#0x00
                                   1691 ;	Receiver.c:315: if(auto_flag)	auto_led=1;
      000635 20*00 01         [24] 1692 	jb	_auto_flag,00233$
      000638 22               [24] 1693 	ret
      000639                       1694 00233$:
                                   1695 ;	assignBit
      000639 D2 A1            [12] 1696 	setb	_P2_1
      00063B 22               [24] 1697 	ret
      00063C                       1698 00140$:
                                   1699 ;	Receiver.c:317: else if(data_r=='c')
      00063C 74 63            [12] 1700 	mov	a,#0x63
      00063E B5*01 13         [24] 1701 	cjne	a,_data_r,00137$
                                   1702 ;	Receiver.c:319: time_delay=7;
      000641 75*06 07         [24] 1703 	mov	_time_delay,#0x07
      000644 75*07 00         [24] 1704 	mov	(_time_delay + 1),#0x00
                                   1705 ;	Receiver.c:320: state = 3;
      000647 75*10 03         [24] 1706 	mov	_state,#0x03
      00064A 75*11 00         [24] 1707 	mov	(_state + 1),#0x00
                                   1708 ;	Receiver.c:321: if(auto_flag)	auto_led=1;
      00064D 20*00 01         [24] 1709 	jb	_auto_flag,00236$
      000650 22               [24] 1710 	ret
      000651                       1711 00236$:
                                   1712 ;	assignBit
      000651 D2 A1            [12] 1713 	setb	_P2_1
      000653 22               [24] 1714 	ret
      000654                       1715 00137$:
                                   1716 ;	Receiver.c:323: else if(data_r=='d')
      000654 74 64            [12] 1717 	mov	a,#0x64
      000656 B5*01 13         [24] 1718 	cjne	a,_data_r,00134$
                                   1719 ;	Receiver.c:325: time_delay=7;
      000659 75*06 07         [24] 1720 	mov	_time_delay,#0x07
      00065C 75*07 00         [24] 1721 	mov	(_time_delay + 1),#0x00
                                   1722 ;	Receiver.c:326: state = 7;
      00065F 75*10 07         [24] 1723 	mov	_state,#0x07
      000662 75*11 00         [24] 1724 	mov	(_state + 1),#0x00
                                   1725 ;	Receiver.c:327: if(auto_flag)	auto_led=1;
      000665 20*00 01         [24] 1726 	jb	_auto_flag,00239$
      000668 22               [24] 1727 	ret
      000669                       1728 00239$:
                                   1729 ;	assignBit
      000669 D2 A1            [12] 1730 	setb	_P2_1
      00066B 22               [24] 1731 	ret
      00066C                       1732 00134$:
                                   1733 ;	Receiver.c:329: else if(data_r=='e')
      00066C 74 65            [12] 1734 	mov	a,#0x65
      00066E B5*01 12         [24] 1735 	cjne	a,_data_r,00131$
                                   1736 ;	Receiver.c:331: time_delay=7;
      000671 75*06 07         [24] 1737 	mov	_time_delay,#0x07
      000674 75*07 00         [24] 1738 	mov	(_time_delay + 1),#0x00
                                   1739 ;	Receiver.c:332: state = 4;
      000677 75*10 04         [24] 1740 	mov	_state,#0x04
      00067A 75*11 00         [24] 1741 	mov	(_state + 1),#0x00
                                   1742 ;	Receiver.c:333: if(auto_flag)	auto_led=1;
      00067D 30*00 5E         [24] 1743 	jnb	_auto_flag,00148$
                                   1744 ;	assignBit
      000680 D2 A1            [12] 1745 	setb	_P2_1
      000682 22               [24] 1746 	ret
      000683                       1747 00131$:
                                   1748 ;	Receiver.c:335: else if(data_r=='f')
      000683 74 66            [12] 1749 	mov	a,#0x66
      000685 B5*01 12         [24] 1750 	cjne	a,_data_r,00128$
                                   1751 ;	Receiver.c:337: time_delay=10;
      000688 75*06 0A         [24] 1752 	mov	_time_delay,#0x0a
      00068B 75*07 00         [24] 1753 	mov	(_time_delay + 1),#0x00
                                   1754 ;	Receiver.c:338: state = 5;
      00068E 75*10 05         [24] 1755 	mov	_state,#0x05
      000691 75*11 00         [24] 1756 	mov	(_state + 1),#0x00
                                   1757 ;	Receiver.c:339: if(auto_flag)	auto_led=1;
      000694 30*00 47         [24] 1758 	jnb	_auto_flag,00148$
                                   1759 ;	assignBit
      000697 D2 A1            [12] 1760 	setb	_P2_1
      000699 22               [24] 1761 	ret
      00069A                       1762 00128$:
                                   1763 ;	Receiver.c:341: else if(data_r=='g')
      00069A 74 67            [12] 1764 	mov	a,#0x67
      00069C B5*01 12         [24] 1765 	cjne	a,_data_r,00125$
                                   1766 ;	Receiver.c:343: time_delay=20;
      00069F 75*06 14         [24] 1767 	mov	_time_delay,#0x14
      0006A2 75*07 00         [24] 1768 	mov	(_time_delay + 1),#0x00
                                   1769 ;	Receiver.c:344: state = 6;
      0006A5 75*10 06         [24] 1770 	mov	_state,#0x06
      0006A8 75*11 00         [24] 1771 	mov	(_state + 1),#0x00
                                   1772 ;	Receiver.c:345: if(auto_flag)	auto_led=1;
      0006AB 30*00 30         [24] 1773 	jnb	_auto_flag,00148$
                                   1774 ;	assignBit
      0006AE D2 A1            [12] 1775 	setb	_P2_1
      0006B0 22               [24] 1776 	ret
      0006B1                       1777 00125$:
                                   1778 ;	Receiver.c:347: else if(data_r=='u')
      0006B1 74 75            [12] 1779 	mov	a,#0x75
      0006B3 B5*01 12         [24] 1780 	cjne	a,_data_r,00122$
                                   1781 ;	Receiver.c:349: time_delay=15;
      0006B6 75*06 0F         [24] 1782 	mov	_time_delay,#0x0f
      0006B9 75*07 00         [24] 1783 	mov	(_time_delay + 1),#0x00
                                   1784 ;	Receiver.c:350: state = 9;
      0006BC 75*10 09         [24] 1785 	mov	_state,#0x09
      0006BF 75*11 00         [24] 1786 	mov	(_state + 1),#0x00
                                   1787 ;	Receiver.c:351: if(auto_flag)	auto_led=1;
      0006C2 30*00 19         [24] 1788 	jnb	_auto_flag,00148$
                                   1789 ;	assignBit
      0006C5 D2 A1            [12] 1790 	setb	_P2_1
      0006C7 22               [24] 1791 	ret
      0006C8                       1792 00122$:
                                   1793 ;	Receiver.c:353: else if(data_r=='n')
      0006C8 74 6E            [12] 1794 	mov	a,#0x6e
      0006CA B5*01 11         [24] 1795 	cjne	a,_data_r,00148$
                                   1796 ;	Receiver.c:355: time_delay=15;
      0006CD 75*06 0F         [24] 1797 	mov	_time_delay,#0x0f
      0006D0 75*07 00         [24] 1798 	mov	(_time_delay + 1),#0x00
                                   1799 ;	Receiver.c:356: state = 8;
      0006D3 75*10 08         [24] 1800 	mov	_state,#0x08
      0006D6 75*11 00         [24] 1801 	mov	(_state + 1),#0x00
                                   1802 ;	Receiver.c:357: if(auto_flag)	auto_led=1;
      0006D9 30*00 02         [24] 1803 	jnb	_auto_flag,00148$
                                   1804 ;	assignBit
      0006DC D2 A1            [12] 1805 	setb	_P2_1
      0006DE                       1806 00148$:
                                   1807 ;	Receiver.c:372: }
      0006DE 22               [24] 1808 	ret
                                   1809 ;------------------------------------------------------------
                                   1810 ;Allocation info for local variables in function 'InitTimer0'
                                   1811 ;------------------------------------------------------------
                                   1812 ;	Receiver.c:374: void InitTimer0(void)
                                   1813 ;	-----------------------------------------
                                   1814 ;	 function InitTimer0
                                   1815 ;	-----------------------------------------
      0006DF                       1816 _InitTimer0:
                                   1817 ;	Receiver.c:376: TMOD |= 0x01;    // Set timer0 in mode 1
      0006DF 43 89 01         [24] 1818 	orl	_TMOD,#0x01
                                   1819 ;	Receiver.c:377: TH0 = 0xee;      // 5 msec reloading time
      0006E2 75 8C EE         [24] 1820 	mov	_TH0,#0xee
                                   1821 ;	Receiver.c:378: TL0 = 0x00;      // First time value
      0006E5 75 8A 00         [24] 1822 	mov	_TL0,#0x00
                                   1823 ;	Receiver.c:379: TR0 = 1;         // Start Timer 1
                                   1824 ;	assignBit
      0006E8 D2 8C            [12] 1825 	setb	_TR0
                                   1826 ;	Receiver.c:380: ET0 = 1;         // Enable Timer1 interrupts	
                                   1827 ;	assignBit
      0006EA D2 A9            [12] 1828 	setb	_ET0
                                   1829 ;	Receiver.c:381: }
      0006EC 22               [24] 1830 	ret
                                   1831 ;------------------------------------------------------------
                                   1832 ;Allocation info for local variables in function 'check_switches'
                                   1833 ;------------------------------------------------------------
                                   1834 ;	Receiver.c:383: void check_switches()
                                   1835 ;	-----------------------------------------
                                   1836 ;	 function check_switches
                                   1837 ;	-----------------------------------------
      0006ED                       1838 _check_switches:
                                   1839 ;	Receiver.c:385: if(!ac_key)
      0006ED 20 93 4F         [24] 1840 	jb	_P1_3,00111$
                                   1841 ;	Receiver.c:387: delay();
      0006F0 12r05r8A         [24] 1842 	lcall	_delay
                                   1843 ;	Receiver.c:388: if(!ac_key)
      0006F3 20 93 49         [24] 1844 	jb	_P1_3,00111$
                                   1845 ;	Receiver.c:390: ac_state++;		
      0006F6 05*14            [12] 1846 	inc	_ac_state
                                   1847 ;	Receiver.c:391: if(ac_state==3)
      0006F8 74 03            [12] 1848 	mov	a,#0x03
      0006FA B5*14 03         [24] 1849 	cjne	a,_ac_state,00102$
                                   1850 ;	Receiver.c:392: ac_state=0;
      0006FD 75*14 00         [24] 1851 	mov	_ac_state,#0x00
      000700                       1852 00102$:
                                   1853 ;	Receiver.c:393: switch(ac_state)
      000700 E4               [12] 1854 	clr	a
      000701 B5*14 02         [24] 1855 	cjne	a,_ac_state,00171$
      000704 80 0E            [24] 1856 	sjmp	00103$
      000706                       1857 00171$:
      000706 74 01            [12] 1858 	mov	a,#0x01
      000708 B5*14 02         [24] 1859 	cjne	a,_ac_state,00172$
      00070B 80 16            [24] 1860 	sjmp	00104$
      00070D                       1861 00172$:
      00070D 74 02            [12] 1862 	mov	a,#0x02
                                   1863 ;	Receiver.c:395: case 0:Transmit_data('l');ac_led_up=1;ac_led_down=1;delay();break;
      00070F B5*14 2D         [24] 1864 	cjne	a,_ac_state,00111$
      000712 80 1E            [24] 1865 	sjmp	00105$
      000714                       1866 00103$:
      000714 75 82 6C         [24] 1867 	mov	dpl,#0x6c
      000717 12r05rBF         [24] 1868 	lcall	_Transmit_data
                                   1869 ;	assignBit
      00071A D2 A2            [12] 1870 	setb	_P2_2
                                   1871 ;	assignBit
      00071C D2 A3            [12] 1872 	setb	_P2_3
      00071E 12r05r8A         [24] 1873 	lcall	_delay
                                   1874 ;	Receiver.c:396: case 1:Transmit_data('m');ac_led_up=1;ac_led_down=0;delay();break;
      000721 80 1C            [24] 1875 	sjmp	00111$
      000723                       1876 00104$:
      000723 75 82 6D         [24] 1877 	mov	dpl,#0x6d
      000726 12r05rBF         [24] 1878 	lcall	_Transmit_data
                                   1879 ;	assignBit
      000729 D2 A2            [12] 1880 	setb	_P2_2
                                   1881 ;	assignBit
      00072B C2 A3            [12] 1882 	clr	_P2_3
      00072D 12r05r8A         [24] 1883 	lcall	_delay
                                   1884 ;	Receiver.c:397: case 2:Transmit_data('h');ac_led_up=0;ac_led_down=1;delay();break;
      000730 80 0D            [24] 1885 	sjmp	00111$
      000732                       1886 00105$:
      000732 75 82 68         [24] 1887 	mov	dpl,#0x68
      000735 12r05rBF         [24] 1888 	lcall	_Transmit_data
                                   1889 ;	assignBit
      000738 C2 A2            [12] 1890 	clr	_P2_2
                                   1891 ;	assignBit
      00073A D2 A3            [12] 1892 	setb	_P2_3
      00073C 12r05r8A         [24] 1893 	lcall	_delay
                                   1894 ;	Receiver.c:399: }//switch end
      00073F                       1895 00111$:
                                   1896 ;	Receiver.c:402: if(!dim_key)
      00073F 20 94 37         [24] 1897 	jb	_P1_4,00115$
                                   1898 ;	Receiver.c:404: delay();
      000742 12r05r8A         [24] 1899 	lcall	_delay
                                   1900 ;	Receiver.c:406: dim_val = dim_val + 2;
      000745 74 02            [12] 1901 	mov	a,#0x02
      000747 25*08            [12] 1902 	add	a,_dim_val
      000749 F5*08            [12] 1903 	mov	_dim_val,a
      00074B E4               [12] 1904 	clr	a
      00074C 35*09            [12] 1905 	addc	a,(_dim_val + 1)
      00074E F5*09            [12] 1906 	mov	(_dim_val + 1),a
                                   1907 ;	Receiver.c:407: dim_val2=8-dim_val;
      000750 74 08            [12] 1908 	mov	a,#0x08
      000752 C3               [12] 1909 	clr	c
      000753 95*08            [12] 1910 	subb	a,_dim_val
      000755 F5*0A            [12] 1911 	mov	_dim_val2,a
      000757 E4               [12] 1912 	clr	a
      000758 95*09            [12] 1913 	subb	a,(_dim_val + 1)
      00075A F5*0B            [12] 1914 	mov	(_dim_val2 + 1),a
                                   1915 ;	Receiver.c:408: if(dim_val>8){dim_val=2;dim_val2=6;}
      00075C C3               [12] 1916 	clr	c
      00075D 74 08            [12] 1917 	mov	a,#0x08
      00075F 95*08            [12] 1918 	subb	a,_dim_val
      000761 74 80            [12] 1919 	mov	a,#(0x00 ^ 0x80)
      000763 85*09 F0         [24] 1920 	mov	b,(_dim_val + 1)
      000766 63 F0 80         [24] 1921 	xrl	b,#0x80
      000769 95 F0            [12] 1922 	subb	a,b
      00076B 50 0C            [24] 1923 	jnc	00115$
      00076D 75*08 02         [24] 1924 	mov	_dim_val,#0x02
      000770 75*09 00         [24] 1925 	mov	(_dim_val + 1),#0x00
      000773 75*0A 06         [24] 1926 	mov	_dim_val2,#0x06
      000776 75*0B 00         [24] 1927 	mov	(_dim_val2 + 1),#0x00
      000779                       1928 00115$:
                                   1929 ;	Receiver.c:412: if(!auto_key)
      000779 20 92 05         [24] 1930 	jb	_P1_2,00117$
                                   1931 ;	Receiver.c:414: delay();
      00077C 12r05r8A         [24] 1932 	lcall	_delay
                                   1933 ;	Receiver.c:415: auto_flag=!auto_flag;
      00077F B2*00            [12] 1934 	cpl	_auto_flag
      000781                       1935 00117$:
                                   1936 ;	Receiver.c:418: if(!pwr_key)
      000781 20 97 1F         [24] 1937 	jb	_P1_7,00121$
                                   1938 ;	Receiver.c:420: delay();
      000784 12r05r8A         [24] 1939 	lcall	_delay
                                   1940 ;	Receiver.c:421: pwr_led=0;P0_1 =0;P0_0 =0;P2_6=0;ac_led_up=0;ac_led_down=0;auto_led=0;
                                   1941 ;	assignBit
      000787 C2 A0            [12] 1942 	clr	_P2_0
                                   1943 ;	assignBit
      000789 C2 81            [12] 1944 	clr	_P0_1
                                   1945 ;	assignBit
      00078B C2 80            [12] 1946 	clr	_P0_0
                                   1947 ;	assignBit
      00078D C2 A6            [12] 1948 	clr	_P2_6
                                   1949 ;	assignBit
      00078F C2 A2            [12] 1950 	clr	_P2_2
                                   1951 ;	assignBit
      000791 C2 A3            [12] 1952 	clr	_P2_3
                                   1953 ;	assignBit
      000793 C2 A1            [12] 1954 	clr	_P2_1
                                   1955 ;	Receiver.c:422: TR0 = 0;         // Stop Timer 1
                                   1956 ;	assignBit
      000795 C2 8C            [12] 1957 	clr	_TR0
                                   1958 ;	Receiver.c:423: ET0 = 0;         // Enable Timer1 interrupts	
                                   1959 ;	assignBit
      000797 C2 A9            [12] 1960 	clr	_ET0
                                   1961 ;	Receiver.c:424: delay();delay();
      000799 12r05r8A         [24] 1962 	lcall	_delay
      00079C 12r05r8A         [24] 1963 	lcall	_delay
                                   1964 ;	Receiver.c:425: pwr_out=1;
                                   1965 ;	assignBit
      00079F D2 87            [12] 1966 	setb	_P0_7
                                   1967 ;	Receiver.c:426: shutdown:
      0007A1                       1968 00118$:
                                   1969 ;	Receiver.c:427: goto shutdown;
      0007A1 80 FE            [24] 1970 	sjmp	00118$
      0007A3                       1971 00121$:
                                   1972 ;	Receiver.c:429: }
      0007A3 22               [24] 1973 	ret
                                   1974 	.area CSEG    (CODE)
                                   1975 	.area CONST   (CODE)
                                   1976 	.area XINIT   (CODE)
                                   1977 	.area CABS    (ABS,CODE)
